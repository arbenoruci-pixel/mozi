{"file_contents":{"index.js":{"content":"// index.js ‚Äî Crypto signal server (EMA crossover + RSI filter)\nconst express = require('express');\nconst fetch = require('node-fetch');\nconst cors = require('cors');\nconst fs = require('fs');\nconst path = require('path');\nconst { EMA, RSI } = require('technicalindicators');\nconst TelegramBot = require('node-telegram-bot-api');\n\n// Pack 1 - Faster Data Layer Modules\nconst OHLCCache = require('./modules/ohlc-cache');\nconst BinanceWS = require('./modules/binance-ws');\nconst HTTPFallback = require('./modules/http-fallback');\n\n// Pack 2 - Strategy Engine v2\nconst StrategyEngine = require('./modules/strategy-engine');\n\n// Paper Trading System\nconst PaperTrading = require('./modules/paper-trading');\n\nconst app = express();\napp.use(cors());\napp.use(express.json());\napp.use(express.static('public'));\n\nconst PORT = process.env.PORT || 5000;\nconst USERS_FILE = path.join(__dirname, 'users.json');\n\n// Supported cryptocurrency symbols (lowercase for API queries)\nconst SUPPORTED_SYMBOLS = [\n  'btc', 'eth', 'sol', 'xrp', 'ada', 'doge',\n  'bnb', 'ltc', 'matic', 'avax', 'dot', 'link'\n];\n\n// Map lowercase symbols to CryptoCompare API ticker codes\nconst SYMBOLS = {\n  btc: 'BTC',\n  eth: 'ETH',\n  sol: 'SOL',\n  xrp: 'XRP',\n  ada: 'ADA',\n  doge: 'DOGE',\n  bnb: 'BNB',\n  ltc: 'LTC',\n  matic: 'MATIC',\n  avax: 'AVAX',\n  dot: 'DOT',\n  link: 'LINK'\n};\n\n// --- Trial System Configuration ---\nconst TRIAL_DAYS = parseInt(process.env.TRIAL_DAYS) || 5;\nconst TRIAL_PLAN = 'trial';\nconst ADMIN_SECRET = process.env.ADMIN_SECRET || '';\n\n// --- Pack 1: Faster Data Layer Configuration ---\nconst BINANCE_WS_ENABLED = (process.env.BINANCE_WS || 'on') === 'on';\nconst HTTP_FALLBACK_ENABLED = (process.env.HTTP_FALLBACK || 'on') === 'on';\n\n// --- Auto-Alert System Configuration ---\nconst TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN || '';\nconst TELEGRAM_CHAT_ID = process.env.TELEGRAM_CHAT_ID || '';\nconst ALERT_EMAIL = process.env.ALERT_EMAIL || '';\nconst CHECK_INTERVAL_MS = 10 * 60 * 1000; // 10 minutes\n\n// Store last signals in memory to detect changes (per strategy-symbol combo)\nconst lastSignals = {\n  day: {},\n  swing: {},\n  long: {}\n};\nSUPPORTED_SYMBOLS.forEach(sym => {\n  lastSignals.day[sym] = null;\n  lastSignals.swing[sym] = null;\n  lastSignals.long[sym] = null;\n});\n\n// --- Initialize Telegram Bot (Webhook mode) ---\nconst WEBHOOK_URL = `https://${process.env.REPLIT_DEV_DOMAIN || 'nodejs-arbenoruci.replit.app'}/telegram/webhook`;\nlet bot;\nif (TELEGRAM_BOT_TOKEN && TELEGRAM_BOT_TOKEN.length > 20) {\n  try {\n    bot = new TelegramBot(TELEGRAM_BOT_TOKEN);\n    console.log('ü§ñ Telegram bot initialized (webhook mode)');\n  } catch (error) {\n    console.error('Failed to initialize Telegram bot:', error.message);\n  }\n} else if (TELEGRAM_BOT_TOKEN) {\n  console.log('‚ö†Ô∏è  TELEGRAM_BOT_TOKEN appears invalid (too short)');\n}\n\n// --- User Management Functions ---\nfunction loadUsers() {\n  try {\n    if (fs.existsSync(USERS_FILE)) {\n      const data = fs.readFileSync(USERS_FILE, 'utf8');\n      const users = JSON.parse(data);\n      // Backfill strategy field for legacy users\n      return users.map(u => ({\n        ...u,\n        strategy: u.strategy || 'swing'\n      }));\n    }\n  } catch (error) {\n    console.error('Error loading users:', error.message);\n  }\n  return [];\n}\n\nfunction saveUsers(users) {\n  try {\n    fs.writeFileSync(USERS_FILE, JSON.stringify(users, null, 2));\n  } catch (error) {\n    console.error('Error saving users:', error.message);\n  }\n}\n\nfunction addDays(dateISO, days) {\n  const date = new Date(dateISO);\n  date.setDate(date.getDate() + days);\n  return date.toISOString();\n}\n\nfunction getActiveUsers() {\n  const users = loadUsers();\n  const now = new Date().toISOString();\n  return users.filter(u => u.expires_at > now);\n}\n\nfunction getUserByChatId(chatId) {\n  const users = loadUsers();\n  return users.find(u => u.chat_id === chatId);\n}\n\nfunction updateUser(chatId, updates) {\n  const users = loadUsers();\n  const index = users.findIndex(u => u.chat_id === chatId);\n  if (index !== -1) {\n    users[index] = { ...users[index], ...updates };\n    saveUsers(users);\n    return users[index];\n  }\n  return null;\n}\n\n// --- Send alert notification to users with matching strategy ---\nasync function sendAlert(symbol, signal, price, lastRSI, strategy) {\n  const strategyEmoji = {\n    'day': '‚ö°',\n    'swing': 'üìä',\n    'long': 'üõ°Ô∏è'\n  }[strategy] || 'üìä';\n  \n  const strategyName = {\n    'day': 'DAY TRADING',\n    'swing': 'SWING TRADING',\n    'long': 'LONG-TERM'\n  }[strategy] || 'SWING TRADING';\n  \n  const message = `${strategyEmoji} ${symbol.toUpperCase()} ${signal}!\\n\\n` +\n    `Strategy: ${strategyName}\\n` +\n    `Signal: ${signal}\\n` +\n    `Price: $${price.toLocaleString()}\\n` +\n    `RSI: ${lastRSI.toFixed(2)}\\n` +\n    `Time: ${new Date().toLocaleString()}`;\n\n  console.log('\\n' + '='.repeat(50));\n  console.log(`[${strategy.toUpperCase()}] ${symbol.toUpperCase()}: ${signal}`);\n  console.log('='.repeat(50) + '\\n');\n\n  // Broadcast only to active users with matching strategy\n  if (bot) {\n    const users = loadUsers();\n    const now = new Date().toISOString();\n    // Default to 'swing' for users without a strategy field (backward compatibility)\n    const matchingUsers = users.filter(u => u.expires_at > now && (u.strategy || 'swing') === strategy);\n    let sentCount = 0;\n    \n    for (const user of matchingUsers) {\n      try {\n        await bot.sendMessage(user.chat_id, message);\n        sentCount++;\n        await new Promise(resolve => setTimeout(resolve, 100));\n      } catch (error) {\n        console.error(`Failed to send to ${user.chat_id}:`, error.message);\n      }\n    }\n    \n    console.log(`‚úÖ Sent to ${sentCount}/${matchingUsers.length} users with ${strategy} strategy`);\n  }\n}\n\n// --- Check signals for all strategies and send alerts on change ---\nasync function checkSignals() {\n  const strategies = ['day', 'swing', 'long'];\n  \n  // Check each strategy separately\n  for (const strategy of strategies) {\n    for (let i = 0; i < SUPPORTED_SYMBOLS.length; i++) {\n      const symbol = SUPPORTED_SYMBOLS[i];\n      try {\n        const data = await getSignal(symbol, strategy);\n        const currentSignal = data.signal;\n        const previousSignal = lastSignals[strategy][symbol];\n\n        // Alert on any change to BUY or SELL (including null‚ÜíBUY/SELL and BUY‚ÜîSELL)\n        const shouldAlert = (currentSignal === 'BUY' || currentSignal === 'SELL') && \n                           currentSignal !== previousSignal;\n\n        if (shouldAlert) {\n          await sendAlert(symbol, currentSignal, data.price, data.lastRSI, strategy);\n        }\n\n        // Update stored signal for this strategy\n        lastSignals[strategy][symbol] = currentSignal;\n\n        console.log(`[${new Date().toLocaleTimeString()}] ${symbol.toUpperCase()} [${strategy}]: ${currentSignal} (prev: ${previousSignal || 'N/A'})`);\n        \n        // Add 500ms delay between requests to avoid rate limiting\n        if (i < SUPPORTED_SYMBOLS.length - 1) {\n          await new Promise(resolve => setTimeout(resolve, 500));\n        }\n      } catch (error) {\n        console.error(`Error checking ${symbol.toUpperCase()} [${strategy}] signal:`, error.message);\n      }\n    }\n  }\n  \n  // Check for expired users and send notification\n  await checkExpiredUsers();\n}\n\n// --- Check for expired users and send one-time notification ---\nasync function checkExpiredUsers() {\n  if (!bot) return;\n  \n  const users = loadUsers();\n  const now = new Date().toISOString();\n  \n  for (const user of users) {\n    // User expired and hasn't been notified\n    if (user.expires_at < now && !user.trial_notified) {\n      try {\n        await bot.sendMessage(\n          user.chat_id,\n          `‚è≥ Your free trial has ended.\\n\\nTo keep receiving crypto alerts, please contact support or upgrade your plan.\\n\\nThank you for trying Arben's Crypto Signals!`\n        );\n        updateUser(user.chat_id, { trial_notified: true });\n        console.log(`üì¢ Sent expiry notification to user ${user.chat_id}`);\n      } catch (error) {\n        console.error(`Failed to notify user ${user.chat_id}:`, error.message);\n      }\n    }\n  }\n}\n\n// --- Telegram Webhook Handler Functions ---\nasync function handleStartCommand(chatId, username, firstName, parameter = '') {\n  let user = getUserByChatId(chatId);\n  const validStrategies = ['day', 'swing', 'long'];\n  const selectedStrategy = validStrategies.includes(parameter) ? parameter : null;\n  \n  if (!user) {\n    const now = new Date().toISOString();\n    const expiresAt = addDays(now, TRIAL_DAYS);\n    const expiryDate = new Date(expiresAt).toLocaleDateString();\n    \n    const newUser = {\n      chat_id: chatId,\n      username,\n      first_name: firstName,\n      plan: TRIAL_PLAN,\n      strategy: selectedStrategy || 'swing',\n      referred_by: null,\n      created_at: now,\n      expires_at: expiresAt,\n      trial_notified: false\n    };\n    \n    const users = loadUsers();\n    if (!users.find(u => u.chat_id === chatId)) {\n      users.push(newUser);\n      saveUsers(users);\n      console.log(`[Trial] Started ${TRIAL_DAYS}-day trial for chat_id=${chatId}, strategy=${newUser.strategy}`);\n    }\n    \n    const strategyName = {\n      'day': '‚ö° DAY TRADING (High Risk)',\n      'swing': 'üìä SWING TRADING (Medium Risk)',\n      'long': 'üõ°Ô∏è LONG-TERM (Low Risk)'\n    }[newUser.strategy] || 'üìä SWING TRADING';\n    \n    return `üëã Welcome to Arben's Crypto Signals!\\n\\n` +\n           `‚úÖ Your ${TRIAL_DAYS}-day trial started!\\n` +\n           `üìà Strategy: ${strategyName}\\n\\n` +\n           `To change strategy, send:\\n` +\n           `/start day - Fast day trading signals\\n` +\n           `/start swing - Balanced swing trading\\n` +\n           `/start long - Patient long-term holds\\n\\n` +\n           `Supported coins: ${SUPPORTED_SYMBOLS.map(s => s.toUpperCase()).join(', ')}\\n\\n` +\n           `Trial expires: ${expiryDate}`;\n  } else {\n    if (selectedStrategy && selectedStrategy !== user.strategy) {\n      updateUser(chatId, { strategy: selectedStrategy });\n      const strategyName = {\n        'day': '‚ö° DAY TRADING (High Risk)',\n        'swing': 'üìä SWING TRADING (Medium Risk)',\n        'long': 'üõ°Ô∏è LONG-TERM (Low Risk)'\n      }[selectedStrategy];\n      console.log(`[Strategy] User ${chatId} switched to ${selectedStrategy}`);\n      return `‚úÖ Strategy updated to ${strategyName}!\\n\\nYou'll now receive signals optimized for this trading style.`;\n    }\n    return `üëã Welcome back${firstName ? ' ' + firstName : ''}!\\n\\nType 'status' to check your subscription or '/start day|swing|long' to change strategy.`;\n  }\n}\n\nasync function handleStatusCommand(chatId) {\n  const user = getUserByChatId(chatId);\n  \n  if (!user) {\n    return `You're not registered yet. Send /start to begin your free trial!`;\n  }\n  \n  const now = new Date();\n  const expiresAt = new Date(user.expires_at);\n  const daysRemaining = Math.max(0, Math.ceil((expiresAt - now) / (1000 * 60 * 60 * 24)));\n  const isActive = user.expires_at > now.toISOString();\n  \n  if (!isActive) {\n    return `Your trial ended ‚Äî contact @arben_crypto_bot to extend.`;\n  }\n  \n  const strategyName = {\n    'day': '‚ö° DAY TRADING (High Risk)',\n    'swing': 'üìä SWING TRADING (Medium Risk)',\n    'long': 'üõ°Ô∏è LONG-TERM (Low Risk)'\n  }[user.strategy] || 'üìä SWING TRADING';\n  \n  let statusMessage = `üìä Subscription Status\\n\\n`;\n  statusMessage += `Plan: ${user.plan.toUpperCase()}\\n`;\n  statusMessage += `Strategy: ${strategyName}\\n`;\n  statusMessage += `Status: ‚úÖ Active\\n`;\n  statusMessage += `Expires: ${expiresAt.toLocaleDateString()}\\n`;\n  statusMessage += `Days left: ${daysRemaining}\\n\\n`;\n  statusMessage += `Coins: ${SUPPORTED_SYMBOLS.map(s => s.toUpperCase()).join(', ')}\\n\\n`;\n  statusMessage += `Change strategy: /start day|swing|long`;\n  \n  return statusMessage;\n}\n\nfunction handleHelpCommand() {\n  const domain = process.env.REPLIT_DEV_DOMAIN || 'nodejs-arbenoruci.replit.app';\n  const dashboardUrl = `https://${domain}/dashboard.html`;\n  \n  return `ü§ñ Arben's Crypto Signals Bot\\n\\n` +\n         `Commands:\\n` +\n         `/start - Begin your 5-day free trial\\n` +\n         `status - Check subscription status\\n\\n` +\n         `Supported: ${SUPPORTED_SYMBOLS.map(s => s.toUpperCase()).join(', ')}\\n\\n` +\n         `üìä View live dashboard: ${dashboardUrl}`;\n}\n\n// --- fetch price data from CryptoCompare (free, no API key required) ---\nasync function getPriceData(symbol = 'btc', timeframe = 'hour', limit = 168) {\n  const fsym = SYMBOLS[symbol] || SYMBOLS.btc;\n  \n  const endpoints = {\n    'minute': `https://min-api.cryptocompare.com/data/v2/histominute?fsym=${fsym}&tsym=USD&limit=${limit}`,\n    'hour': `https://min-api.cryptocompare.com/data/v2/histohour?fsym=${fsym}&tsym=USD&limit=${limit}`,\n    'day': `https://min-api.cryptocompare.com/data/v2/histoday?fsym=${fsym}&tsym=USD&limit=${limit}`\n  };\n  \n  const url = endpoints[timeframe] || endpoints.hour;\n  \n  const res = await fetch(url);\n  if (!res.ok) throw new Error(`CryptoCompare API error ${res.status}`);\n  const json = await res.json();\n  \n  if (json.Response === 'Error') {\n    throw new Error(json.Message || 'API error');\n  }\n  \n  if (!json.Data || !json.Data.Data || json.Data.Data.length === 0) {\n    throw new Error('No price data available');\n  }\n  \n  return json.Data.Data.map(candle => candle.close);\n}\n\nasync function getHourlyPrices(symbol = 'btc', days = 7) {\n  return getPriceData(symbol, 'hour', days * 24);\n}\n\n// --- generate trading signals for different strategies ---\n\n// DAY TRADING: 15-min candles, EMA 5/13, aggressive signals\nasync function getDayTradingSignal(symbol = 'btc') {\n  const minuteData = await getPriceData(symbol, 'minute', 2000);\n  \n  if (minuteData.length < 300) {\n    return { signal: 'HOLD', reason: 'Not enough data', strategy: 'day' };\n  }\n  \n  const closes = [];\n  for (let i = 14; i < minuteData.length; i += 15) {\n    closes.push(minuteData[i]);\n  }\n  \n  if (closes.length < 20) {\n    return { signal: 'HOLD', reason: 'Not enough data', strategy: 'day' };\n  }\n  \n  const emaFast = EMA.calculate({ period: 5, values: closes });\n  const emaSlow = EMA.calculate({ period: 13, values: closes });\n  const rsiVals = RSI.calculate({ period: 14, values: closes });\n  \n  const n = Math.min(emaFast.length, emaSlow.length, rsiVals.length);\n  if (n < 3) return { signal: 'HOLD', reason: 'Not enough data', strategy: 'day' };\n  \n  const f = emaFast.slice(-n);\n  const s = emaSlow.slice(-n);\n  const r = rsiVals.slice(-n);\n  const price = closes[closes.length - 1];\n  \n  const crossedUp = f[n - 2] <= s[n - 2] && f[n - 1] > s[n - 1];\n  const crossedDown = f[n - 2] >= s[n - 2] && f[n - 1] < s[n - 1];\n  const lastRSI = r[r.length - 1];\n  \n  if (crossedUp && lastRSI < 75) {\n    return { signal: 'BUY', price, lastRSI, emaFast: f[n - 1], emaSlow: s[n - 1], strategy: 'day' };\n  }\n  if (crossedDown && lastRSI > 25) {\n    return { signal: 'SELL', price, lastRSI, emaFast: f[n - 1], emaSlow: s[n - 1], strategy: 'day' };\n  }\n  return { signal: 'HOLD', price, lastRSI, emaFast: f[n - 1], emaSlow: s[n - 1], strategy: 'day' };\n}\n\n// SWING TRADING: 4-hour candles, EMA 8/21, balanced signals\nasync function getSwingTradingSignal(symbol = 'btc') {\n  const hourlyData = await getPriceData(symbol, 'hour', 350);\n  \n  if (hourlyData.length < 100) {\n    return { signal: 'HOLD', reason: 'Not enough data', strategy: 'swing' };\n  }\n  \n  const closes = [];\n  for (let i = 3; i < hourlyData.length; i += 4) {\n    closes.push(hourlyData[i]);\n  }\n  \n  if (closes.length < 25) {\n    return { signal: 'HOLD', reason: 'Not enough data', strategy: 'swing' };\n  }\n  \n  const emaFast = EMA.calculate({ period: 8, values: closes });\n  const emaSlow = EMA.calculate({ period: 21, values: closes });\n  const rsiVals = RSI.calculate({ period: 14, values: closes });\n  \n  const n = Math.min(emaFast.length, emaSlow.length, rsiVals.length);\n  if (n < 3) return { signal: 'HOLD', reason: 'Not enough data', strategy: 'swing' };\n  \n  const f = emaFast.slice(-n);\n  const s = emaSlow.slice(-n);\n  const r = rsiVals.slice(-n);\n  const price = closes[closes.length - 1];\n  \n  const crossedUp = f[n - 2] <= s[n - 2] && f[n - 1] > s[n - 1];\n  const crossedDown = f[n - 2] >= s[n - 2] && f[n - 1] < s[n - 1];\n  const lastRSI = r[r.length - 1];\n  \n  if (crossedUp && lastRSI < 70) {\n    return { signal: 'BUY', price, lastRSI, emaFast: f[n - 1], emaSlow: s[n - 1], strategy: 'swing' };\n  }\n  if (crossedDown && lastRSI > 30) {\n    return { signal: 'SELL', price, lastRSI, emaFast: f[n - 1], emaSlow: s[n - 1], strategy: 'swing' };\n  }\n  return { signal: 'HOLD', price, lastRSI, emaFast: f[n - 1], emaSlow: s[n - 1], strategy: 'swing' };\n}\n\n// LONG-TERM: Daily candles, EMA 50/200, patient signals\nasync function getLongTermSignal(symbol = 'btc') {\n  const closes = await getPriceData(symbol, 'day', 250);\n  \n  if (closes.length < 205) {\n    return { signal: 'HOLD', reason: 'Not enough data', strategy: 'long' };\n  }\n  \n  const emaFast = EMA.calculate({ period: 50, values: closes });\n  const emaSlow = EMA.calculate({ period: 200, values: closes });\n  const rsiVals = RSI.calculate({ period: 14, values: closes });\n  \n  const n = Math.min(emaFast.length, emaSlow.length, rsiVals.length);\n  if (n < 3) return { signal: 'HOLD', reason: 'Not enough data', strategy: 'long' };\n  \n  const f = emaFast.slice(-n);\n  const s = emaSlow.slice(-n);\n  const r = rsiVals.slice(-n);\n  const price = closes[closes.length - 1];\n  \n  const crossedUp = f[n - 2] <= s[n - 2] && f[n - 1] > s[n - 1];\n  const crossedDown = f[n - 2] >= s[n - 2] && f[n - 1] < s[n - 1];\n  const lastRSI = r[r.length - 1];\n  \n  if (crossedUp && lastRSI < 65) {\n    return { signal: 'BUY', price, lastRSI, emaFast: f[n - 1], emaSlow: s[n - 1], strategy: 'long' };\n  }\n  if (crossedDown && lastRSI > 35) {\n    return { signal: 'SELL', price, lastRSI, emaFast: f[n - 1], emaSlow: s[n - 1], strategy: 'long' };\n  }\n  return { signal: 'HOLD', price, lastRSI, emaFast: f[n - 1], emaSlow: s[n - 1], strategy: 'long' };\n}\n\n// Wrapper function to get signal based on strategy\nasync function getSignal(symbol = 'btc', strategy = 'swing') {\n  if (strategy === 'day') return getDayTradingSignal(symbol);\n  if (strategy === 'long') return getLongTermSignal(symbol);\n  return getSwingTradingSignal(symbol);\n}\n\n// --- toy paper trader (stateless-ish demo) ---\nlet paper = {\n  cash: 1000,         // start fake balance\n  position: 0,        // units (e.g., BTC)\n  lastPrice: null\n};\n\nasync function stepPaper(symbol = 'btc') {\n  const s = await getSignal(symbol);\n  const price = s.price;\n  paper.lastPrice = price;\n\n  // simple rules: all-in buy/sell on signals (for demo only!)\n  if (s.signal === 'BUY' && paper.cash > 1) {\n    paper.position = paper.cash / price;\n    paper.cash = 0;\n  } else if (s.signal === 'SELL' && paper.position > 0) {\n    paper.cash = paper.position * price;\n    paper.position = 0;\n  }\n  const equity = paper.cash + paper.position * price;\n  return { ...s, paper: { ...paper, equity: Number(equity.toFixed(2)) } };\n}\n\n// --- routes ---\n\n// Health check endpoint\napp.get('/api/health', (req, res) => {\n  res.json({ ok: true, msg: 'healthy' });\n});\n\n// Get list of supported symbols\napp.get('/api/symbols', (req, res) => {\n  res.json({ \n    ok: true, \n    symbols: SUPPORTED_SYMBOLS,\n    count: SUPPORTED_SYMBOLS.length\n  });\n});\n\n// Root dashboard route\napp.get('/', (req, res) => {\n  const domain = process.env.REPLIT_DEV_DOMAIN || 'localhost:5000';\n  const protocol = domain.includes('localhost') ? 'http' : 'https';\n  const baseUrl = `${protocol}://${domain}`;\n  \n  res.send(`\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Crypto Signal API Dashboard</title>\n  <style>\n    * { margin: 0; padding: 0; box-sizing: border-box; }\n    body {\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n      min-height: 100vh;\n      padding: 20px;\n    }\n    .container {\n      max-width: 900px;\n      margin: 0 auto;\n      background: white;\n      border-radius: 20px;\n      padding: 40px;\n      box-shadow: 0 20px 60px rgba(0,0,0,0.3);\n    }\n    h1 {\n      color: #333;\n      margin-bottom: 10px;\n      font-size: 2.5em;\n    }\n    .subtitle {\n      color: #666;\n      margin-bottom: 30px;\n      font-size: 1.1em;\n    }\n    .section {\n      margin: 30px 0;\n    }\n    .section h2 {\n      color: #667eea;\n      margin-bottom: 15px;\n      font-size: 1.5em;\n      border-bottom: 2px solid #f0f0f0;\n      padding-bottom: 10px;\n    }\n    .endpoint {\n      background: #f8f9fa;\n      padding: 15px;\n      margin: 10px 0;\n      border-radius: 10px;\n      border-left: 4px solid #667eea;\n    }\n    .endpoint a {\n      color: #667eea;\n      text-decoration: none;\n      font-weight: 500;\n      display: block;\n      margin: 5px 0;\n    }\n    .endpoint a:hover {\n      text-decoration: underline;\n    }\n    .description {\n      color: #666;\n      font-size: 0.9em;\n      margin-top: 5px;\n    }\n    .badge {\n      display: inline-block;\n      padding: 4px 10px;\n      background: #28a745;\n      color: white;\n      border-radius: 12px;\n      font-size: 0.8em;\n      margin-left: 10px;\n    }\n    .info-box {\n      background: #e7f3ff;\n      padding: 15px;\n      border-radius: 10px;\n      margin: 20px 0;\n      border-left: 4px solid #2196F3;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <h1>üöÄ Crypto Signal API</h1>\n    <p class=\"subtitle\">Real-time cryptocurrency trading signals using EMA & RSI technical analysis</p>\n    \n    <div class=\"info-box\">\n      <strong>üåê Public Access:</strong> This API is live and accessible externally<br>\n      <strong>üìä Supported Cryptos (12):</strong> BTC, ETH, SOL, XRP, ADA, DOGE, BNB, LTC, MATIC, AVAX, DOT, LINK\n    </div>\n\n    <div class=\"section\">\n      <h2>System Health</h2>\n      <div class=\"endpoint\">\n        <a href=\"/api/health\" target=\"_blank\">/api/health</a>\n        <span class=\"badge\">GET</span>\n        <p class=\"description\">Returns server health status</p>\n      </div>\n      <div class=\"endpoint\">\n        <a href=\"/api/symbols\" target=\"_blank\">/api/symbols</a>\n        <span class=\"badge\">GET</span>\n        <p class=\"description\">Get list of all supported cryptocurrency symbols</p>\n      </div>\n    </div>\n\n    <div class=\"section\">\n      <h2>Trading Signals</h2>\n      <div class=\"endpoint\">\n        <a href=\"/api/signal?symbol=btc\" target=\"_blank\">/api/signal?symbol=btc</a>\n        <span class=\"badge\">GET</span>\n        <p class=\"description\">Get BUY/SELL/HOLD signal for Bitcoin with EMA & RSI analysis</p>\n      </div>\n      <div class=\"endpoint\">\n        <a href=\"/api/signal?symbol=eth\" target=\"_blank\">/api/signal?symbol=eth</a>\n        <span class=\"badge\">GET</span>\n        <p class=\"description\">Get trading signal for Ethereum</p>\n      </div>\n      <div class=\"endpoint\">\n        <a href=\"/api/signal?symbol=sol\" target=\"_blank\">/api/signal?symbol=sol</a>\n        <span class=\"badge\">GET</span>\n        <p class=\"description\">Get trading signal for Solana</p>\n      </div>\n      <div class=\"endpoint\">\n        <a href=\"/api/signal?symbol=avax\" target=\"_blank\">/api/signal?symbol=avax</a>\n        <span class=\"badge\">GET</span>\n        <p class=\"description\">Get trading signal for Avalanche</p>\n      </div>\n      <div class=\"endpoint\">\n        <a href=\"/api/signal?symbol=link\" target=\"_blank\">/api/signal?symbol=link</a>\n        <span class=\"badge\">GET</span>\n        <p class=\"description\">Get trading signal for Chainlink</p>\n      </div>\n      <div class=\"endpoint\">\n        <a href=\"/api/signal?symbol=bnb\" target=\"_blank\">/api/signal?symbol=bnb</a>\n        <span class=\"badge\">GET</span>\n        <p class=\"description\">Get trading signal for Binance Coin</p>\n      </div>\n      <p style=\"margin-top:10px; color:#666; font-size:0.9em;\">Support for 12 cryptocurrencies total - use /api/symbols for the full list</p>\n    </div>\n\n    <div class=\"section\">\n      <h2>Paper Trading</h2>\n      <div class=\"endpoint\">\n        <a href=\"/api/paper?symbol=btc\" target=\"_blank\">/api/paper?symbol=btc</a>\n        <span class=\"badge\">GET</span>\n        <p class=\"description\">Get signal with simulated paper trading portfolio</p>\n      </div>\n    </div>\n\n    <div class=\"section\">\n      <h2>Alert System</h2>\n      <div class=\"endpoint\">\n        <a href=\"/api/alerts/status\" target=\"_blank\">/api/alerts/status</a>\n        <span class=\"badge\">GET</span>\n        <p class=\"description\">View auto-alert system status (monitors BTC & ETH every 10 minutes)</p>\n      </div>\n    </div>\n\n    <div class=\"section\">\n      <h2>üì± Web Dashboard</h2>\n      <div class=\"endpoint\">\n        <a href=\"/dashboard.html\" target=\"_blank\">/dashboard.html</a>\n        <span class=\"badge\">VIEW</span>\n        <p class=\"description\">Interactive web dashboard with auto-refreshing crypto cards</p>\n      </div>\n    </div>\n  </div>\n</body>\n</html>\n  `);\n});\n\napp.get('/api/signal', async (req, res) => {\n  try {\n    const symbol = (req.query.symbol || 'btc').toLowerCase();\n    const strategy = (req.query.strategy || 'swing').toLowerCase();\n    \n    // Validate symbol\n    if (!SUPPORTED_SYMBOLS.includes(symbol)) {\n      return res.status(400).json({ ok: false, error: 'unsupported symbol' });\n    }\n    \n    // Validate strategy\n    if (!['day', 'swing', 'long'].includes(strategy)) {\n      return res.status(400).json({ ok: false, error: 'invalid strategy. Use: day, swing, or long' });\n    }\n    \n    const data = await getSignal(symbol, strategy);\n    const time = new Date().toISOString();\n    res.json({ ok: true, symbol, strategy, time, ...data });\n  } catch (e) {\n    res.status(500).json({ ok: false, error: String(e) });\n  }\n});\n\napp.get('/api/paper', async (req, res) => {\n  try {\n    const symbol = (req.query.symbol || 'btc').toLowerCase();\n    \n    // Validate symbol\n    if (!SUPPORTED_SYMBOLS.includes(symbol)) {\n      return res.status(400).json({ ok: false, error: 'unsupported symbol' });\n    }\n    \n    const data = await stepPaper(symbol);\n    res.json({ ok: true, symbol, ...data });\n  } catch (e) {\n    res.status(500).json({ ok: false, error: String(e) });\n  }\n});\n\napp.get('/api/alerts/status', (req, res) => {\n  res.json({\n    ok: true,\n    alertSystem: 'active',\n    monitoredSymbols: SUPPORTED_SYMBOLS,\n    symbolCount: SUPPORTED_SYMBOLS.length,\n    checkInterval: '10 minutes',\n    telegramConfigured: !!(TELEGRAM_BOT_TOKEN && TELEGRAM_CHAT_ID),\n    lastSignals: lastSignals,\n    nextCheckIn: CHECK_INTERVAL_MS / 1000 / 60 + ' minutes'\n  });\n});\n\napp.post('/api/alerts/check-now', async (req, res) => {\n  try {\n    await checkSignals();\n    res.json({ \n      ok: true, \n      message: 'Signal check completed',\n      currentSignals: lastSignals\n    });\n  } catch (e) {\n    res.status(500).json({ ok: false, error: String(e) });\n  }\n});\n\napp.get('/api/test-alert', async (req, res) => {\n  if (!TELEGRAM_BOT_TOKEN || !TELEGRAM_CHAT_ID) {\n    return res.json({ ok: false, error: 'Telegram not configured' });\n  }\n\n  try {\n    const telegramUrl = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;\n    const response = await fetch(telegramUrl, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        chat_id: TELEGRAM_CHAT_ID,\n        text: 'Test alert from CryptoBot ‚úÖ'\n      })\n    });\n\n    if (response.ok) {\n      res.json({ ok: true, message: 'Test alert sent successfully' });\n    } else {\n      const error = await response.text();\n      res.json({ ok: false, error: `Telegram API error: ${error}` });\n    }\n  } catch (e) {\n    res.status(500).json({ ok: false, error: String(e) });\n  }\n});\n\n// --- Admin Authentication Middleware ---\nfunction requireAdmin(req, res, next) {\n  const authHeader = req.headers.authorization;\n  const providedSecret = authHeader?.replace('Bearer ', '');\n  \n  if (!ADMIN_SECRET) {\n    return res.status(503).json({\n      ok: false,\n      error: 'Admin endpoints disabled. Set ADMIN_SECRET in environment.'\n    });\n  }\n  \n  if (!providedSecret || providedSecret !== ADMIN_SECRET) {\n    return res.status(401).json({\n      ok: false,\n      error: 'Unauthorized. Valid admin token required.'\n    });\n  }\n  \n  next();\n}\n\n// --- User Management Admin APIs (Protected) ---\n\napp.get('/api/users', requireAdmin, (req, res) => {\n  try {\n    const users = loadUsers();\n    const activeOnly = req.query.active === '1' || req.query.active === 'true';\n    \n    let filteredUsers = users;\n    if (activeOnly) {\n      const now = new Date().toISOString();\n      filteredUsers = users.filter(u => u.expires_at > now);\n    }\n    \n    // Return minimal necessary data (exclude referral codes)\n    const publicUsers = filteredUsers.map(u => ({\n      chat_id: u.chat_id,\n      username: u.username,\n      first_name: u.first_name,\n      plan: u.plan,\n      created_at: u.created_at,\n      expires_at: u.expires_at\n    }));\n    \n    res.json({\n      ok: true,\n      count: publicUsers.length,\n      users: publicUsers\n    });\n  } catch (e) {\n    res.status(500).json({ ok: false, error: String(e) });\n  }\n});\n\napp.post('/api/user/activate', requireAdmin, (req, res) => {\n  try {\n    const { chat_id, plan, days } = req.body;\n    \n    if (!chat_id || !plan || !days) {\n      return res.status(400).json({\n        ok: false,\n        error: 'Required fields: chat_id, plan, days'\n      });\n    }\n    \n    const user = getUserByChatId(chat_id);\n    if (!user) {\n      return res.status(404).json({\n        ok: false,\n        error: 'User not found'\n      });\n    }\n    \n    const now = new Date().toISOString();\n    const expiresAt = addDays(now, parseInt(days));\n    \n    const updatedUser = updateUser(chat_id, {\n      plan: plan,\n      expires_at: expiresAt,\n      trial_notified: false\n    });\n    \n    // Notify user about activation\n    if (bot) {\n      bot.sendMessage(\n        chat_id,\n        `üéâ Your subscription has been activated!\\n\\n` +\n        `Plan: ${plan.toUpperCase()}\\n` +\n        `Valid until: ${new Date(expiresAt).toLocaleDateString()}\\n\\n` +\n        `You'll continue receiving crypto alerts for all supported coins!`\n      ).catch(err => console.error('Failed to notify user:', err.message));\n    }\n    \n    console.log(`[Activation] User ${chat_id} activated: ${plan} for ${days} days`);\n    \n    res.json({\n      ok: true,\n      message: 'User activated successfully',\n      user: {\n        chat_id: updatedUser.chat_id,\n        plan: updatedUser.plan,\n        expires_at: updatedUser.expires_at\n      }\n    });\n  } catch (e) {\n    res.status(500).json({ ok: false, error: String(e) });\n  }\n});\n\n// --- Broadcast Message to All Active Users ---\napp.post('/api/broadcast', requireAdmin, async (req, res) => {\n  try {\n    const { message } = req.body;\n    \n    if (!message) {\n      return res.status(400).json({\n        ok: false,\n        error: 'Required field: message'\n      });\n    }\n    \n    if (!bot) {\n      return res.status(503).json({\n        ok: false,\n        error: 'Telegram bot not initialized'\n      });\n    }\n    \n    const users = loadUsers();\n    const now = new Date().toISOString();\n    const activeUsers = users.filter(u => u.expires_at > now);\n    \n    let successCount = 0;\n    let failCount = 0;\n    const results = [];\n    \n    for (const user of activeUsers) {\n      try {\n        await bot.sendMessage(user.chat_id, message);\n        successCount++;\n        results.push({ chat_id: user.chat_id, status: 'sent' });\n        await new Promise(resolve => setTimeout(resolve, 100));\n      } catch (error) {\n        failCount++;\n        results.push({ chat_id: user.chat_id, status: 'failed', error: error.message });\n        console.error(`Failed to send to ${user.chat_id}:`, error.message);\n      }\n    }\n    \n    console.log(`[Broadcast] Sent to ${successCount}/${activeUsers.length} users`);\n    \n    res.json({\n      ok: true,\n      message: 'Broadcast completed',\n      total_active_users: activeUsers.length,\n      success: successCount,\n      failed: failCount,\n      results: results\n    });\n  } catch (e) {\n    res.status(500).json({ ok: false, error: String(e) });\n  }\n});\n\n// --- Telegram Webhook Endpoint (Secured with token validation) ---\napp.post('/telegram/webhook', async (req, res) => {\n  try {\n    // Verify request is from Telegram by checking secret token header\n    const secretToken = req.headers['x-telegram-bot-api-secret-token'];\n    const expectedToken = process.env.WEBHOOK_SECRET || 'default-secret-change-me';\n    \n    if (secretToken !== expectedToken) {\n      console.warn('[Webhook] Unauthorized request - invalid secret token');\n      return res.sendStatus(401);\n    }\n    \n    const update = req.body;\n    \n    if (!update.message) {\n      return res.sendStatus(200);\n    }\n    \n    const chatId = update.message.chat.id;\n    const text = (update.message.text || '').trim();\n    const username = update.message.from?.username || '';\n    const firstName = update.message.from?.first_name || '';\n    \n    console.log(`[Webhook] Received: \"${text}\" from ${chatId}`);\n    \n    let responseText;\n    \n    if (text.startsWith('/start')) {\n      const referralCode = text.replace('/start', '').trim();\n      responseText = await handleStartCommand(chatId, username, firstName, referralCode);\n    } else if (text.toLowerCase() === 'status' || text === '/status') {\n      responseText = await handleStatusCommand(chatId);\n    } else {\n      responseText = handleHelpCommand();\n    }\n    \n    if (bot && responseText) {\n      await bot.sendMessage(chatId, responseText);\n    }\n    \n    res.sendStatus(200);\n  } catch (error) {\n    console.error('[Webhook] Error:', error.message);\n    res.sendStatus(500);\n  }\n});\n\n// ========================================\n// PACK 1 - FASTER DATA LAYER API ENDPOINTS\n// ========================================\n\n// Initialize Pack 1 & 2 modules\nlet ohlcCache, binanceWS, httpFallback, strategyEngine, paperTrading;\n\nfunction initializePack1() {\n  console.log('\\nüìä Initializing Pack 1: Faster Data Layer...');\n  \n  // Create OHLC cache\n  ohlcCache = new OHLCCache(500);\n  console.log('‚úÖ OHLC Cache initialized (500 bars per timeframe)');\n  \n  // Create HTTP fallback\n  httpFallback = new HTTPFallback(ohlcCache, { enabled: HTTP_FALLBACK_ENABLED });\n  console.log(`${HTTP_FALLBACK_ENABLED ? '‚úÖ' : 'üü°'} HTTP Fallback ${HTTP_FALLBACK_ENABLED ? 'enabled' : 'disabled'}`);\n  \n  // Create and start Binance WebSocket\n  binanceWS = new BinanceWS(ohlcCache, { enabled: BINANCE_WS_ENABLED });\n  if (BINANCE_WS_ENABLED) {\n    binanceWS.connect();\n    console.log('‚úÖ Binance WebSocket connecting...');\n  } else {\n    console.log('üü° Binance WebSocket disabled');\n  }\n  \n  // Initialize cache with historical data if HTTP fallback enabled\n  if (HTTP_FALLBACK_ENABLED) {\n    httpFallback.initializeCache().then(() => {\n      console.log('‚úÖ Historical data loaded into cache');\n    }).catch(err => {\n      console.error('‚ùå Error loading historical data:', err.message);\n    });\n  }\n}\n\nfunction initializePack2() {\n  console.log('\\nüéØ Initializing Pack 2: Strategy Engine v2...');\n  \n  if (!ohlcCache) {\n    console.error('‚ùå Cannot initialize Pack 2: OHLC Cache not available');\n    return;\n  }\n  \n  strategyEngine = new StrategyEngine(ohlcCache);\n  console.log('‚úÖ Strategy Engine v2 initialized (multi-indicator, multi-timeframe)');\n}\n\nasync function initializePaperTrading() {\n  console.log('\\nüí∞ Initializing Paper Trading System...');\n  \n  if (!strategyEngine) {\n    console.error('‚ùå Cannot initialize Paper Trading: Strategy Engine not available');\n    return;\n  }\n  \n  paperTrading = new PaperTrading(strategyEngine, {\n    initialBalance: 1000,\n    positionSize: 0.10,\n    maxPositions: 3,\n    stopLossPct: 0.02,\n    takeProfitPct: 0.05,\n    plan: 'short'\n  });\n  \n  await paperTrading.initialize();\n  console.log('‚úÖ Paper Trading initialized ($1000 balance, day trading strategy)');\n  \n  setInterval(async () => {\n    try {\n      const actions = await paperTrading.checkAndExecuteTrades(SUPPORTED_SYMBOLS);\n      if (actions.length > 0) {\n        console.log(`üìä Paper Trading: ${actions.length} actions executed`);\n      }\n    } catch (err) {\n      console.error('‚ùå Paper trading error:', err.message);\n    }\n  }, 60000);\n  \n  console.log('‚úÖ Paper Trading auto-check enabled (every 60 seconds)');\n}\n\n// GET /api/price?symbol=btc - Get latest price and source\napp.get('/api/price', (req, res) => {\n  try {\n    const symbol = (req.query.symbol || 'btc').toLowerCase();\n    \n    if (!SUPPORTED_SYMBOLS.includes(symbol)) {\n      return res.status(400).json({ ok: false, error: 'unsupported symbol' });\n    }\n    \n    if (!ohlcCache) {\n      return res.status(503).json({ ok: false, error: 'data layer not initialized' });\n    }\n    \n    const priceData = ohlcCache.getLatestPrice(symbol);\n    \n    res.json({\n      ok: true,\n      symbol,\n      price: priceData.price,\n      source: priceData.source,\n      timestamp: priceData.time,\n      time: priceData.time ? new Date(priceData.time).toISOString() : null\n    });\n  } catch (e) {\n    res.status(500).json({ ok: false, error: String(e) });\n  }\n});\n\n// GET /api/ohlc?symbol=btc&tf=1m&count=100 - Get OHLC bars\napp.get('/api/ohlc', (req, res) => {\n  try {\n    const symbol = (req.query.symbol || 'btc').toLowerCase();\n    const timeframe = req.query.tf || '1m';\n    const count = parseInt(req.query.count) || 100;\n    \n    if (!SUPPORTED_SYMBOLS.includes(symbol)) {\n      return res.status(400).json({ ok: false, error: 'unsupported symbol' });\n    }\n    \n    if (!ohlcCache) {\n      return res.status(503).json({ ok: false, error: 'data layer not initialized' });\n    }\n    \n    const bars = ohlcCache.getBars(symbol, timeframe, count);\n    \n    res.json({\n      ok: true,\n      symbol,\n      timeframe,\n      count: bars.length,\n      bars\n    });\n  } catch (e) {\n    res.status(500).json({ ok: false, error: String(e) });\n  }\n});\n\n// GET /api/metrics - Get data layer metrics\napp.get('/api/metrics', (req, res) => {\n  try {\n    if (!ohlcCache) {\n      return res.status(503).json({ ok: false, error: 'data layer not initialized' });\n    }\n    \n    const cacheMetrics = ohlcCache.getMetrics();\n    const wsStatus = binanceWS ? binanceWS.getStatus() : { enabled: false };\n    \n    res.json({\n      ok: true,\n      websocket: wsStatus,\n      httpFallback: {\n        enabled: HTTP_FALLBACK_ENABLED\n      },\n      cache: cacheMetrics,\n      timestamp: Date.now()\n    });\n  } catch (e) {\n    res.status(500).json({ ok: false, error: String(e) });\n  }\n});\n\n// ========================================\n// PACK 2 - STRATEGY ENGINE V2 API ENDPOINTS\n// ========================================\n\n// GET /api/plan-signal?symbol=btc&plan=short|mid|long\napp.get('/api/plan-signal', async (req, res) => {\n  try {\n    const symbol = (req.query.symbol || 'btc').toLowerCase();\n    const plan = req.query.plan || 'mid';\n    \n    if (!SUPPORTED_SYMBOLS.includes(symbol)) {\n      return res.status(400).json({ ok: false, error: 'unsupported symbol' });\n    }\n    \n    if (!['short', 'mid', 'long'].includes(plan)) {\n      return res.status(400).json({ ok: false, error: 'invalid plan. Use: short, mid, or long' });\n    }\n    \n    if (!strategyEngine) {\n      return res.status(503).json({ ok: false, error: 'strategy engine not initialized' });\n    }\n    \n    const analysis = await strategyEngine.analyzeSymbol(symbol, plan);\n    const time = new Date().toISOString();\n    \n    res.json({\n      ok: true,\n      symbol,\n      plan,\n      time,\n      ...analysis\n    });\n  } catch (e) {\n    res.status(500).json({ ok: false, error: String(e) });\n  }\n});\n\n// ========================================\n// PAPER TRADING API ENDPOINTS\n// ========================================\n\n// GET /api/paper/performance - Get overall performance metrics\napp.get('/api/paper/performance', async (req, res) => {\n  try {\n    if (!paperTrading) {\n      return res.status(503).json({ ok: false, error: 'paper trading not initialized' });\n    }\n    \n    const performance = await paperTrading.getPerformance();\n    \n    res.json({\n      ok: true,\n      ...performance\n    });\n  } catch (e) {\n    res.status(500).json({ ok: false, error: String(e) });\n  }\n});\n\n// GET /api/paper/trades?limit=50 - Get recent trades\napp.get('/api/paper/trades', (req, res) => {\n  try {\n    if (!paperTrading) {\n      return res.status(503).json({ ok: false, error: 'paper trading not initialized' });\n    }\n    \n    const limit = parseInt(req.query.limit) || 50;\n    const trades = paperTrading.getTrades(limit);\n    \n    res.json({\n      ok: true,\n      trades,\n      count: trades.length\n    });\n  } catch (e) {\n    res.status(500).json({ ok: false, error: String(e) });\n  }\n});\n\n// GET /api/paper/positions - Get current open positions\napp.get('/api/paper/positions', async (req, res) => {\n  try {\n    if (!paperTrading) {\n      return res.status(503).json({ ok: false, error: 'paper trading not initialized' });\n    }\n    \n    const positions = await paperTrading.getPositions();\n    \n    res.json({\n      ok: true,\n      positions,\n      count: positions.length\n    });\n  } catch (e) {\n    res.status(500).json({ ok: false, error: String(e) });\n  }\n});\n\n// --- Set Telegram Webhook ---\nasync function setTelegramWebhook() {\n  if (!bot) {\n    console.log('‚ö†Ô∏è  Bot not initialized, skipping webhook setup');\n    return;\n  }\n  \n  try {\n    const secretToken = process.env.WEBHOOK_SECRET || 'default-secret-change-me';\n    const webhookUrl = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/setWebhook`;\n    const response = await fetch(webhookUrl, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ \n        url: WEBHOOK_URL,\n        secret_token: secretToken\n      })\n    });\n    \n    const result = await response.json();\n    \n    if (result.ok) {\n      console.log('‚úÖ Webhook registered successfully!');\n      console.log('   URL:', WEBHOOK_URL);\n      console.log('   Telegram notifications: ENABLED');\n    } else {\n      console.error('‚ùå Failed to set webhook:', result.description);\n    }\n  } catch (error) {\n    console.error('‚ùå Error setting webhook:', error.message);\n  }\n}\n\napp.listen(PORT, '0.0.0.0', async () => {\n  console.log(`Server on http://0.0.0.0:${PORT}`);\n  \n  // Initialize Pack 1: Faster Data Layer\n  initializePack1();\n  \n  // Initialize Pack 2: Strategy Engine v2 (after Pack 1 cache is ready)\n  setTimeout(() => initializePack2(), 2000);\n  \n  // Initialize Paper Trading (after Pack 2 strategy engine is ready)\n  setTimeout(() => initializePaperTrading(), 4000);\n  \n  console.log('\\nüîî Auto-Alert System Starting...');\n  console.log(`Monitoring ${SUPPORTED_SYMBOLS.length} cryptocurrencies: ${SUPPORTED_SYMBOLS.join(', ').toUpperCase()}`);\n  console.log(`Check interval: ${CHECK_INTERVAL_MS / 1000 / 60} minutes`);\n  \n  if (TELEGRAM_BOT_TOKEN) {\n    console.log('‚úÖ Telegram notifications: ENABLED (webhook mode)');\n    await setTelegramWebhook();\n  } else {\n    console.log('üü° Telegram notifications: DISABLED (console only)');\n    console.log('   To enable: Set TELEGRAM_BOT_TOKEN in Secrets');\n  }\n  \n  // Run initial check after 30 seconds\n  setTimeout(() => {\n    console.log('\\nüîç Running initial signal check...');\n    checkSignals();\n  }, 30000);\n  \n  // Then check every 10 minutes\n  setInterval(() => {\n    console.log('\\nüîç Running scheduled signal check...');\n    checkSignals();\n  }, CHECK_INTERVAL_MS);\n});","size_bytes":43501},"README.md":{"content":"# üöÄ Crypto Signal API\n\nReal-time cryptocurrency trading signals using EMA (Exponential Moving Average) crossover strategy combined with RSI (Relative Strength Index) filtering. This API provides BUY/SELL/HOLD recommendations for 6 major cryptocurrencies.\n\n## üìä Features\n\n- **12 Cryptocurrencies Supported**: BTC, ETH, SOL, XRP, ADA, DOGE, BNB, LTC, MATIC, AVAX, DOT, LINK\n- **Dynamic Symbol Management**: Easily add or remove coins by editing `SUPPORTED_SYMBOLS` array\n- **Technical Analysis**: EMA (8/21 period) crossover with RSI filtering\n- **Real-time Data**: Fetches live price data from CryptoCompare API\n- **Auto-Alert System**: Monitors all supported coins every 10 minutes for signal changes\n- **Paper Trading**: Simulated trading portfolio to backtest strategies\n- **Dynamic Web Dashboard**: Auto-generates cards for all supported coins with live data\n- **REST API**: Simple JSON endpoints for easy integration\n- **No Authentication Required**: Free CryptoCompare API integration\n\n## üåê Production Deployment\n\n**Live URL**: `https://nodejs-arbenoruci.replit.app`\n\n**Deployment Type**: Autoscale (production-ready, auto-scaling)\n\n### ‚úÖ Quick Test Links\n\nTest all endpoints externally:\n\n- **API Dashboard**: [`https://nodejs-arbenoruci.replit.app/`](https://nodejs-arbenoruci.replit.app/)\n- **Live Crypto Cards**: [`https://nodejs-arbenoruci.replit.app/dashboard.html`](https://nodejs-arbenoruci.replit.app/dashboard.html) (shows all 12 coins)\n- **Supported Symbols**: [`https://nodejs-arbenoruci.replit.app/api/symbols`](https://nodejs-arbenoruci.replit.app/api/symbols)\n- **Health Check**: [`https://nodejs-arbenoruci.replit.app/api/health`](https://nodejs-arbenoruci.replit.app/api/health)\n\n**Trading Signals (All 12 Coins):**\n- **BTC Signal**: [`https://nodejs-arbenoruci.replit.app/api/signal?symbol=btc`](https://nodejs-arbenoruci.replit.app/api/signal?symbol=btc)\n- **ETH Signal**: [`https://nodejs-arbenoruci.replit.app/api/signal?symbol=eth`](https://nodejs-arbenoruci.replit.app/api/signal?symbol=eth)\n- **SOL Signal**: [`https://nodejs-arbenoruci.replit.app/api/signal?symbol=sol`](https://nodejs-arbenoruci.replit.app/api/signal?symbol=sol)\n- **XRP Signal**: [`https://nodejs-arbenoruci.replit.app/api/signal?symbol=xrp`](https://nodejs-arbenoruci.replit.app/api/signal?symbol=xrp)\n- **ADA Signal**: [`https://nodejs-arbenoruci.replit.app/api/signal?symbol=ada`](https://nodejs-arbenoruci.replit.app/api/signal?symbol=ada)\n- **DOGE Signal**: [`https://nodejs-arbenoruci.replit.app/api/signal?symbol=doge`](https://nodejs-arbenoruci.replit.app/api/signal?symbol=doge)\n- **BNB Signal**: [`https://nodejs-arbenoruci.replit.app/api/signal?symbol=bnb`](https://nodejs-arbenoruci.replit.app/api/signal?symbol=bnb)\n- **LTC Signal**: [`https://nodejs-arbenoruci.replit.app/api/signal?symbol=ltc`](https://nodejs-arbenoruci.replit.app/api/signal?symbol=ltc)\n- **MATIC Signal**: [`https://nodejs-arbenoruci.replit.app/api/signal?symbol=matic`](https://nodejs-arbenoruci.replit.app/api/signal?symbol=matic)\n- **AVAX Signal**: [`https://nodejs-arbenoruci.replit.app/api/signal?symbol=avax`](https://nodejs-arbenoruci.replit.app/api/signal?symbol=avax)\n- **DOT Signal**: [`https://nodejs-arbenoruci.replit.app/api/signal?symbol=dot`](https://nodejs-arbenoruci.replit.app/api/signal?symbol=dot)\n- **LINK Signal**: [`https://nodejs-arbenoruci.replit.app/api/signal?symbol=link`](https://nodejs-arbenoruci.replit.app/api/signal?symbol=link)\n\n**Other Endpoints:**\n- **Paper Trading (Any Coin)**: [`https://nodejs-arbenoruci.replit.app/api/paper?symbol=avax`](https://nodejs-arbenoruci.replit.app/api/paper?symbol=avax)\n- **Alert System Status**: [`https://nodejs-arbenoruci.replit.app/api/alerts/status`](https://nodejs-arbenoruci.replit.app/api/alerts/status)\n\n### üìä Expected Responses\n\n**Health Check:**\n```json\n{\"ok\": true, \"msg\": \"healthy\"}\n```\n\n**Trading Signal Example:**\n```json\n{\n  \"ok\": true,\n  \"symbol\": \"btc\",\n  \"time\": \"2025-11-11T16:08:39.985Z\",\n  \"signal\": \"HOLD\",\n  \"price\": 103295.11,\n  \"lastRSI\": 32.1,\n  \"emaFast\": 104282.50,\n  \"emaSlow\": 104916.70\n}\n```\n\n## üîß API Endpoints\n\n### Health Check\n```\nGET /api/health\n```\nReturns: `{\"ok\": true, \"msg\": \"healthy\"}`\n\n### Get Supported Symbols\n```\nGET /api/symbols\n```\nReturns: `{\"ok\": true, \"symbols\": [...], \"count\": 12}`\n\n### Get Trading Signal\n```\nGET /api/signal?symbol={crypto}\n```\n**Parameters:**\n- `symbol` (string): btc, eth, sol, xrp, ada, doge, bnb, ltc, matic, avax, dot, or link\n\n**Response:**\n```json\n{\n  \"ok\": true,\n  \"symbol\": \"btc\",\n  \"time\": \"2025-11-11T07:30:00.000Z\",\n  \"signal\": \"BUY|SELL|HOLD\",\n  \"price\": 105190.81,\n  \"lastRSI\": 45.52,\n  \"emaFast\": 105622.80,\n  \"emaSlow\": 105676.29\n}\n```\n\n### Paper Trading\n```\nGET /api/paper?symbol={crypto}\n```\nReturns signal with simulated portfolio status.\n\n### Alert System Status\n```\nGET /api/alerts/status\n```\nView auto-alert monitoring status and last signals.\n\n### Check Signals Now\n```\nPOST /api/alerts/check-now\n```\nManually trigger signal check (returns current signals).\n\n### Test Telegram Alert\n```\nGET /api/test-alert\n```\nSend test notification (requires TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID).\n\n## üì± Web Dashboards\n\n### API Dashboard\nVisit `/` for a complete API explorer with:\n- All available endpoints\n- Interactive links to test each route\n- Documentation for each crypto supported\n\n### Live Crypto Cards\nVisit `/dashboard.html` for:\n- **Dynamic grid** showing all 12 supported cryptocurrencies\n- Real-time price updates for each coin\n- Visual signal indicators (color-coded BUY/SELL/HOLD)\n- EMA and RSI values for technical analysis\n- Auto-refresh every 30 seconds\n- Automatically updates when new coins are added to `SUPPORTED_SYMBOLS`\n\n## üîî Telegram Bot & Trial System\n\n### Free 5-Day Trial\n\nAll new users who join via Telegram automatically receive a **5-day free trial** with full access to crypto alerts!\n\n**How to Join:**\n1. Search for **@arben_crypto_bot** on Telegram\n2. Send `/start` to begin your free trial\n3. Receive instant BUY/SELL alerts for all 12 cryptocurrencies\n\n**Bot Commands:**\n- `/start` - Begin your free 5-day trial (new users only)\n- `/status` - Check your subscription status and expiry date\n\n### Trial Features\n\n**During Your Free Trial:**\n- ‚úÖ Real-time alerts for all 12 cryptocurrencies\n- ‚úÖ BUY/SELL/HOLD signals delivered instantly\n- ‚úÖ Auto-monitoring every 10 minutes\n- ‚úÖ No credit card required\n\n**What Happens After Trial:**\n- Automatic expiry notification sent via Telegram\n- Contact support to upgrade to a paid plan\n- Use admin API endpoints to activate subscriptions\n\n### Alert Broadcasting\n\nThe system automatically broadcasts alerts to **all active (non-expired) users**:\n- Monitors all 12 cryptocurrencies\n- Checks every 10 minutes\n- Only sends alerts when signals change from HOLD to BUY/SELL\n- Includes price, RSI, and timestamp in each alert\n\n### Admin API - User Management\n\n**Security Note**: Admin endpoints require authentication. Set `ADMIN_SECRET` environment variable and include it in requests as `Authorization: Bearer <your-secret>`.\n\n**Get All Users:**\n```bash\nGET /api/users?active=1\nAuthorization: Bearer your-admin-secret-here\n```\nReturns list of active users (filters by expiry date).\n\n**Activate/Extend User Subscription:**\n```bash\nPOST /api/user/activate\nAuthorization: Bearer your-admin-secret-here\nContent-Type: application/json\n\n{\n  \"chat_id\": 123456789,\n  \"plan\": \"basic\",\n  \"days\": 30\n}\n```\nUpgrades a user from trial to paid plan or extends existing subscription.\n\n**Authentication Errors:**\n- `401 Unauthorized` - Invalid or missing admin token\n- `503 Service Unavailable` - ADMIN_SECRET not configured\n\n### Setup Instructions for Bot Admin\n\n1. Create a Telegram bot via [@BotFather](https://t.me/botfather)\n2. Add secrets in Replit:\n   - `TELEGRAM_BOT_TOKEN`: Your bot token from BotFather\n   - `ADMIN_SECRET`: Strong secret token for admin API access (required for /api/users and /api/user/activate)\n   - `TELEGRAM_CHAT_ID`: (Optional) Your admin chat ID for testing\n   - `TRIAL_DAYS`: (Optional) Override default 5-day trial period\n\n**Security Best Practices:**\n- Use a strong, randomly-generated ADMIN_SECRET (e.g., 32+ characters)\n- Never commit ADMIN_SECRET to your repository\n- Admin endpoints return 503 if ADMIN_SECRET is not configured\n\n## üìà Trading Strategy\n\n**EMA Crossover Strategy:**\n- **Fast EMA**: 8-period\n- **Slow EMA**: 21-period\n- **BUY**: Fast EMA crosses above Slow EMA\n- **SELL**: Fast EMA crosses below Slow EMA\n- **HOLD**: No crossover or insufficient data\n\n**RSI Filter:**\n- RSI calculated over 14-period\n- Helps identify overbought/oversold conditions\n- Displayed with each signal for additional context\n\n**Data Source:**\n- Hourly candles over 7-day window (168 data points)\n- Requires minimum 25 candles for reliable calculations\n- CryptoCompare API (free tier, no authentication)\n\n## üõ†Ô∏è Technical Stack\n\n- **Runtime**: Node.js 22\n- **Framework**: Express.js\n- **API Client**: node-fetch\n- **Technical Indicators**: technicalindicators library\n- **Deployment**: Replit Autoscale (production-ready)\n\n## üìù Configuration\n\n**Environment Variables:**\n- `PORT`: Server port (default: 5000)\n- `TELEGRAM_BOT_TOKEN`: Optional Telegram bot token\n- `TELEGRAM_CHAT_ID`: Optional Telegram chat ID\n\n**Auto-Alert Settings:**\n- Monitoring: All 12 supported coins (BTC, ETH, SOL, XRP, ADA, DOGE, BNB, LTC, MATIC, AVAX, DOT, LINK)\n- Check interval: 10 minutes\n- Trial length: 5 days (configurable via `TRIAL_DAYS` env variable)\n- Notification triggers: HOLD ‚Üí BUY/SELL transitions\n\n## ‚öôÔ∏è How to Add/Remove Cryptocurrencies\n\nTo add or remove supported coins, edit the `SUPPORTED_SYMBOLS` array in `index.js`:\n\n```javascript\nconst SUPPORTED_SYMBOLS = [\n  'btc', 'eth', 'sol', 'xrp', 'ada', 'doge',\n  'bnb', 'ltc', 'matic', 'avax', 'dot', 'link'\n  // Add more coins here (use lowercase)\n];\n```\n\nThen update the `SYMBOLS` mapping with the CryptoCompare ticker code:\n\n```javascript\nconst SYMBOLS = {\n  btc: 'BTC',\n  eth: 'ETH',\n  // ... existing coins ...\n  yournewcoin: 'TICKER'  // Add mapping here\n};\n```\n\nThe dashboard will automatically display all coins in `SUPPORTED_SYMBOLS`. No other code changes needed!\n\n## üöÄ Local Development\n\n```bash\n# Install dependencies\nnpm install\n\n# Start server\nnpm start\n# or\nnode index.js\n```\n\nServer runs on `http://localhost:5000`\n\n## üìÑ License\n\nMIT License - Free to use and modify\n","size_bytes":10391},"attached_assets/content-1762885445498.md":{"content":"```\nCannot GET /telegram/webhook\n```","size_bytes":36},"attached_assets/content-1762885450111.md":{"content":"Failed to load signal data\n\nAuto-refreshing every 30 seconds \\| Last update: 1:24:12 PM","size_bytes":87},"ALERTS.md":{"content":"# Auto-Alert System & Trial Mode Documentation\n\n## Overview\nYour crypto signal server includes an automatic alert system with a built-in **5-day free trial** for all new Telegram users. The system monitors all 12 supported cryptocurrencies every 10 minutes and broadcasts alerts to active subscribers when signals change.\n\n## üÜì Free Trial System\n\n### How Trial Mode Works\n\n**New User Flow:**\n1. User finds **@arben_crypto_bot** on Telegram\n2. Sends `/start` command\n3. Automatically receives 5-day trial access\n4. Gets welcome message with expiry date\n5. Starts receiving live BUY/SELL alerts immediately\n\n**Trial Features:**\n- **Duration**: 5 days (configurable)\n- **Plan Type**: \"trial\"\n- **Access**: Full alerts for all 12 cryptocurrencies\n- **Expiry Notification**: Automatic one-time message when trial ends\n\n### Bot Commands\n\n**`/start [referral_code]`**\n- Registers new users with instant trial activation\n- Existing users receive welcome back message\n- Optional referral code tracking for partner programs\n\n**`/status`**\n- Shows current subscription plan (trial/basic/premium)\n- Displays expiry date and days remaining\n- Indicates if trial is active or expired\n\n### Trial Expiry Flow\n\nWhen a trial expires:\n1. User automatically stops receiving alerts\n2. One-time expiry notification sent via Telegram\n3. Message includes instructions to contact support\n4. User flagged as `trial_notified: true` (prevents repeat messages)\n\n## How Alert Broadcasting Works\n\n### Signal Monitoring\n- **Frequency**: Checks all 12 cryptocurrencies every 10 minutes\n- **Alert Trigger**: Only sends when signal changes from HOLD ‚Üí BUY or HOLD ‚Üí SELL\n- **Recipient Filtering**: Broadcasts only to active (non-expired) users\n- **Memory Storage**: Tracks last known signal for each coin to detect changes\n\n### Broadcast System\n\n**Multi-User Broadcasting:**\n- System loads all users from `users.json`\n- Filters by `expires_at > current_time` (active users only)\n- Sends alerts to each active user's `chat_id`\n- 100ms delay between messages to avoid rate limits\n- Logs success/failure for each recipient\n\n**Message Format:**\n```\nüö® CRYPTO ALERT - BTC\n\nSignal: BUY\nPrice: $106,653\nRSI: 61.74\nTime: 11/11/2025, 6:44:00 AM\n```\n\n## Admin Setup\n\n### 1. Create Telegram Bot\n\n**Via BotFather:**\n1. Message [@BotFather](https://t.me/BotFather) on Telegram\n2. Send `/newbot` and follow instructions\n3. Choose a name: \"Arben Crypto Signals\"\n4. Choose username: `@arben_crypto_bot` (or similar)\n5. Save the bot token (format: `123456789:ABCdefGHIjklMNOpqrsTUVwxyz`)\n\n### 2. Configure Replit Secrets\n\nAdd in Replit Tools ‚Üí Secrets:\n- **`TELEGRAM_BOT_TOKEN`** = your bot token from BotFather\n- **`ADMIN_SECRET`** = strong random token for admin API authentication (required)\n- **`TELEGRAM_CHAT_ID`** = (Optional) your personal chat ID for testing\n- **`TRIAL_DAYS`** = (Optional) Override default 5-day trial\n\n**Security:**\n- Generate ADMIN_SECRET with: `openssl rand -base64 32` or similar\n- Keep ADMIN_SECRET private - it grants full user management access\n- Admin endpoints disabled if ADMIN_SECRET not set\n\n**Note:** When bot is initialized, it uses polling mode (works on Replit without webhooks).\n\n## API Endpoints\n\n### User Management (Admin - Protected)\n\n**üîí Authentication Required**: All admin endpoints require `ADMIN_SECRET` in Authorization header.\n\n**Get All Users:**\n```bash\nGET /api/users\nAuthorization: Bearer your-admin-secret-here\n```\nReturns all registered users with their subscription details.\n\n**Get Active Users Only:**\n```bash\nGET /api/users?active=1\nAuthorization: Bearer your-admin-secret-here\n```\nFilters to show only users with valid (non-expired) subscriptions.\n\n**Response Example:**\n```json\n{\n  \"ok\": true,\n  \"count\": 15,\n  \"users\": [\n    {\n      \"chat_id\": 123456789,\n      \"username\": \"john_crypto\",\n      \"first_name\": \"John\",\n      \"plan\": \"trial\",\n      \"created_at\": \"2025-11-11T10:00:00.000Z\",\n      \"expires_at\": \"2025-11-16T10:00:00.000Z\",\n      \"trial_notified\": false\n    }\n  ]\n}\n```\n\n**Activate/Upgrade User:**\n```bash\nPOST /api/user/activate\nAuthorization: Bearer your-admin-secret-here\nContent-Type: application/json\n\n{\n  \"chat_id\": 123456789,\n  \"plan\": \"basic\",\n  \"days\": 30\n}\n```\n\nConverts trial users to paid plans or extends existing subscriptions.\n\n**Security Notes:**\n- ADMIN_SECRET must be set as environment variable\n- Without ADMIN_SECRET, endpoints return `503 Service Unavailable`\n- Invalid/missing token returns `401 Unauthorized`\n- Referral data excluded from API responses for privacy\n\n**Response:**\n```json\n{\n  \"ok\": true,\n  \"message\": \"User activated successfully\",\n  \"user\": {\n    \"chat_id\": 123456789,\n    \"plan\": \"basic\",\n    \"expires_at\": \"2025-12-11T10:00:00.000Z\"\n  }\n}\n```\n\n**Note:** User automatically receives Telegram notification about activation.\n\n### Alert System\n\n**Check Alert Status:**\n```\nGET /api/alerts/status\n```\nReturns current alert system status, monitored symbols, and last known signals.\n\n**Manual Signal Check:**\n```\nPOST /api/alerts/check-now\n```\nTriggers immediate signal check for all coins (useful for testing).\n\n## Alert Message Format\n```\nüö® CRYPTO ALERT - BTC\n\nSignal: BUY\nPrice: $106,653\nRSI: 61.74\nTime: 11/11/2025, 6:44:00 AM\n```\n\n## User Data Management\n\n### Storage\nUser data is stored in `users.json` with this structure:\n```json\n{\n  \"chat_id\": 123456789,\n  \"username\": \"trader_pro\",\n  \"first_name\": \"Alex\",\n  \"plan\": \"trial\",\n  \"referred_by\": null,\n  \"created_at\": \"2025-11-11T10:00:00.000Z\",\n  \"expires_at\": \"2025-11-16T10:00:00.000Z\",\n  \"trial_notified\": false\n}\n```\n\n### Adding/Removing Coins\n\nTo monitor additional cryptocurrencies:\n1. Edit `SUPPORTED_SYMBOLS` array in `index.js`\n2. Add corresponding ticker to `SYMBOLS` mapping\n3. Restart server\n\nExample:\n```javascript\nconst SUPPORTED_SYMBOLS = ['btc', 'eth', 'sol', 'atom']; // Added ATOM\nconst SYMBOLS = {\n  btc: 'BTC',\n  eth: 'ETH', \n  sol: 'SOL',\n  atom: 'ATOM' // Add mapping\n};\n```\n\nEverything else (dashboard, alerts, endpoints) updates automatically!\n\n### Changing Trial Length\n\n**Option 1:** Environment Variable (recommended)\n```\nTRIAL_DAYS=7\n```\n\n**Option 2:** Edit `index.js`\n```javascript\nconst TRIAL_DAYS = parseInt(process.env.TRIAL_DAYS) || 5; // Change default\n```\n\n## Troubleshooting\n\n**Bot not responding to /start?**\n- Verify `TELEGRAM_BOT_TOKEN` is set correctly in Replit Secrets\n- Check server console for \"ü§ñ Telegram bot initialized with polling\"\n- Look for polling errors in console logs\n- Restart the workflow after adding secrets\n\n**Alerts not sending to users?**\n- Check `/api/users?active=1` to see active user count\n- Verify users have `expires_at > current_time`\n- Check console for \"Alert broadcast to X/Y active users\"\n- Look for Telegram API errors in logs\n\n**Trial not starting?**\n- Ensure `users.json` file exists and is writable\n- Check console for `[Trial] Started 5-day trial for chat_id=...`\n- Verify user record was created with `/api/users`\n\n**Expiry notification not sent?**\n- Check `trial_notified` field in user record\n- Notification only sent once per user\n- Triggered during signal check cycle (every 10 minutes)\n\n## Testing Workflow\n\n1. **Test Bot Registration:**\n   ```bash\n   # Send /start to @arben_crypto_bot\n   # Check console for trial creation log\n   curl http://localhost:5000/api/users | jq\n   ```\n\n2. **Test User Status:**\n   ```bash\n   # Send /status to bot\n   # Verify expiry date is 5 days from now\n   ```\n\n3. **Test Manual Activation:**\n   ```bash\n   curl -X POST http://localhost:5000/api/user/activate \\\n     -H \"Authorization: Bearer your-admin-secret\" \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"chat_id\": 123456789, \"plan\": \"basic\", \"days\": 30}'\n   ```\n\n4. **Test Alert Broadcast:**\n   ```bash\n   curl -X POST http://localhost:5000/api/alerts/check-now\n   # Check console for broadcast count\n   ```\n\n5. **Monitor Alert System:**\n   ```bash\n   curl http://localhost:5000/api/alerts/status | jq\n   ```\n","size_bytes":7923},"attached_assets/content-1762885448042.md":{"content":"","size_bytes":0},"replit.md":{"content":"# Crypto Trading Signal Server with Multi-Strategy System\n\n## Overview\n\nThis project is a cryptocurrency trading signal generator offering a 5-day free trial for Telegram users. It provides automated BUY/SELL/HOLD alerts based on three distinct trading strategies (Day Trading, Swing Trading, Long-Term). These strategies analyze 12 cryptocurrencies using Exponential Moving Average (EMA) crossovers combined with Relative Strength Index (RSI) filtering, each optimized for different risk tolerances and trading styles. A Telegram bot (@arben_crypto_bot) delivers strategy-specific alerts. The system also includes a live paper trading system with a public dashboard for transparency, automatically executing trades based on the day trading strategy.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### UI/UX Decisions\n\n- **Dashboard Multi-Strategy View**: Features tab-based filtering for \"All Strategies\", \"Day Trading\", \"Swing Trading\", and \"Long-Term\". Displays all 36 strategy-symbol combinations with color-coded strategy badges and real-time signal updates every 30 seconds.\n- **Paper Trading Dashboard**: A public dashboard (`/paper-trading.html`) showcases portfolio value, total return, win rate, open positions with unrealized P/L, and complete trade history. It auto-refreshes every 10 seconds for real-time transparency.\n\n### Technical Implementations\n\n- **Multi-Strategy Trading System**: Implements three strategies (Day Trading, Swing Trading, Long-Term) with distinct timeframes, EMA parameters, and RSI thresholds. Users can select their preferred strategy via Telegram commands.\n- **Alert System**: Employs a per-strategy signal tracking mechanism (`lastSignals`) to detect changes to BUY or SELL signals across all strategies and symbols. Alerts are broadcast to active users subscribed to the matching strategy, with a 100ms delay between messages to manage Telegram rate limits.\n- **Paper Trading System**: Utilizes a `modules/paper-trading.js` engine for automated trade execution based on the day trading strategy, managing position sizing (10% of balance per trade, max 3 concurrent positions), stop-loss (-2%), and take-profit (+5%). It performs mark-to-market valuations and tracks performance metrics like win rate, profit factor, and max drawdown.\n- **User Management**: A file-based system (`users.json`) stores user data for trial management, subscription tracking, and referral codes, avoiding the need for a traditional database for simplicity. New users receive an automatic 5-day trial, and an admin API is available for upgrading plans.\n\n### Feature Specifications\n\n- **Signal Generation**: Stateless signal generation calculates technical indicators on-demand using fresh data.\n- **Strategy Selection**: Users can select or change their preferred trading strategy via Telegram commands.\n- **Automated Alerts**: Strategy-specific BUY/SELL/HOLD alerts are sent to users.\n- **Paper Trading**: Automated execution of trades for a transparent demonstration of strategy performance.\n- **Trial System**: 5-day free trial for new users with automated expiry notifications.\n\n### System Design Choices\n\n- **Backend**: Node.js/Express REST API server.\n- **Data Source**: CryptoCompare free API for historical cryptocurrency price data.\n- **Signal Logic**: EMA crossover (e.g., Fast EMA 5, Slow EMA 13 for Day Trading) combined with RSI filtering (e.g., <75 for BUY, >25 for SELL for Day Trading).\n- **Data Persistence**: File-based storage (`users.json`, `paper-portfolio.json`) for user data and paper trading state, prioritizing simplicity over large-scale database management.\n- **Error Handling**: Robust error handling for file I/O, Telegram API interactions, and external API calls to ensure system resilience.\n- **Performance**: Delays implemented for API calls (e.g., 500ms for CryptoCompare, 100ms for Telegram messages) and dashboard refreshes to adhere to rate limits and manage load.\n\n## External Dependencies\n\n### Third-Party APIs\n\n- **CryptoCompare API (`min-api.cryptocompare.com`)**: Used for fetching hourly historical cryptocurrency price data via the `/data/v2/histohour` endpoint. No authentication is required for the free tier.\n- **Telegram Bot API**: Utilized for sending automated trading alerts and handling user commands via the `node-telegram-bot-api` library.\n\n### NPM Libraries\n\n- **express**: Core web server framework.\n- **cors**: Enables cross-origin requests.\n- **node-fetch**: HTTP client for external API calls, primarily for CryptoCompare.\n- **technicalindicators**: Library for calculating technical analysis indicators like EMA and RSI.\n- **node-telegram-bot-api**: Wrapper for the Telegram Bot API.\n\n### Infrastructure Requirements\n\n- **Node.js**: Runtime environment.\n- **Telegram Bot Token**: Required for bot functionality.\n- **Internet Connectivity**: For external API access.","size_bytes":4902},"attached_assets/content-1762877198730.md":{"content":"```\nNot Found\n```","size_bytes":17},"attached_assets/content-1762885440080.md":{"content":"```\nNot Found\n```","size_bytes":17},"modules/ohlc-cache.js":{"content":"// OHLC Cache Module - In-memory cache for candlestick data\n// Maintains rolling window of OHLC bars for multiple timeframes\n\nclass OHLCCache {\n  constructor(maxBars = 500) {\n    this.maxBars = maxBars;\n    this.cache = {}; // { symbol: { '1m': [...bars], '5m': [...bars] } }\n    this.lastTick = {}; // { symbol: { price, time, source } }\n    this.errors = {}; // { symbol: count }\n    \n    // Initialize cache for all symbols\n    this.symbols = ['btc', 'eth', 'sol', 'xrp', 'ada', 'doge', 'bnb', 'ltc', 'matic', 'avax', 'dot', 'link'];\n    this.timeframes = ['1m', '5m'];\n    \n    this.symbols.forEach(symbol => {\n      this.cache[symbol] = {};\n      this.timeframes.forEach(tf => {\n        this.cache[symbol][tf] = [];\n      });\n      this.lastTick[symbol] = { price: null, time: null, source: null };\n      this.errors[symbol] = 0;\n    });\n    \n    // Current incomplete candles\n    this.currentCandles = {}; // { symbol: { '1m': {...}, '5m': {...} } }\n    this.symbols.forEach(symbol => {\n      this.currentCandles[symbol] = {};\n      this.timeframes.forEach(tf => {\n        this.currentCandles[symbol][tf] = null;\n      });\n    });\n  }\n\n  // Update price tick from WebSocket or HTTP\n  updateTick(symbol, price, source = 'ws') {\n    const now = Date.now();\n    this.lastTick[symbol] = { price, time: now, source };\n    \n    // Update all timeframes\n    this.timeframes.forEach(tf => {\n      this.updateOHLC(symbol, tf, price, now);\n    });\n  }\n\n  // Update OHLC for a specific timeframe\n  updateOHLC(symbol, timeframe, price, timestamp) {\n    const tfMs = this.getTimeframeMs(timeframe);\n    const candleStart = Math.floor(timestamp / tfMs) * tfMs;\n    \n    const current = this.currentCandles[symbol][timeframe];\n    \n    // Check if we need to close the current candle and start a new one\n    if (!current || current.time !== candleStart) {\n      // Close previous candle if exists\n      if (current) {\n        this.addCompletedCandle(symbol, timeframe, current);\n      }\n      \n      // Start new candle\n      this.currentCandles[symbol][timeframe] = {\n        time: candleStart,\n        open: price,\n        high: price,\n        low: price,\n        close: price,\n        volume: 0\n      };\n    } else {\n      // Update current candle\n      current.high = Math.max(current.high, price);\n      current.low = Math.min(current.low, price);\n      current.close = price;\n    }\n  }\n\n  // Add completed candle to cache\n  addCompletedCandle(symbol, timeframe, candle) {\n    const cache = this.cache[symbol][timeframe];\n    cache.push(candle);\n    \n    // Keep only last maxBars\n    if (cache.length > this.maxBars) {\n      cache.shift();\n    }\n  }\n\n  // Get OHLC bars for a symbol and timeframe\n  getBars(symbol, timeframe = '1m', count = 100) {\n    if (!this.cache[symbol] || !this.cache[symbol][timeframe]) {\n      return [];\n    }\n    \n    const bars = this.cache[symbol][timeframe];\n    return bars.slice(-count);\n  }\n\n  // Get latest price\n  getLatestPrice(symbol) {\n    return this.lastTick[symbol];\n  }\n\n  // Get metrics for monitoring\n  getMetrics() {\n    const metrics = {\n      symbols: {},\n      totalBars: 0,\n      lastUpdate: Date.now()\n    };\n    \n    this.symbols.forEach(symbol => {\n      const tick = this.lastTick[symbol];\n      metrics.symbols[symbol] = {\n        lastPrice: tick.price,\n        lastTick: tick.time,\n        source: tick.source,\n        errors: this.errors[symbol] || 0,\n        bars: {}\n      };\n      \n      this.timeframes.forEach(tf => {\n        const count = this.cache[symbol][tf].length;\n        metrics.symbols[symbol].bars[tf] = count;\n        metrics.totalBars += count;\n      });\n    });\n    \n    return metrics;\n  }\n\n  // Increment error counter\n  recordError(symbol) {\n    this.errors[symbol] = (this.errors[symbol] || 0) + 1;\n  }\n\n  // Convert timeframe string to milliseconds\n  getTimeframeMs(tf) {\n    const map = {\n      '1m': 60 * 1000,\n      '5m': 5 * 60 * 1000,\n      '15m': 15 * 60 * 1000,\n      '1h': 60 * 60 * 1000\n    };\n    return map[tf] || 60 * 1000;\n  }\n\n  // Bulk load historical bars (for initialization or backfill)\n  loadHistoricalBars(symbol, timeframe, bars) {\n    if (!this.cache[symbol] || !this.cache[symbol][timeframe]) {\n      return;\n    }\n    \n    // Add bars and keep only last maxBars\n    this.cache[symbol][timeframe] = bars.slice(-this.maxBars);\n    \n    console.log(`[OHLC] Loaded ${bars.length} ${timeframe} bars for ${symbol.toUpperCase()}`);\n  }\n}\n\nmodule.exports = OHLCCache;\n","size_bytes":4460},"modules/strategy-engine.js":{"content":"// Strategy Engine v2 - Multi-indicator, multi-timeframe voting system\n// Implements EMA, RSI, MACD, Bollinger Bands, and ATR across multiple timeframes\n\nconst { EMA, RSI, MACD, BollingerBands, ATR } = require('technicalindicators');\n\nclass StrategyEngine {\n  constructor(ohlcCache) {\n    this.ohlcCache = ohlcCache;\n    \n    // Timeframes to analyze\n    this.timeframes = ['1m', '5m', '15m', '1h'];\n    \n    // Plan configurations (weights for each timeframe)\n    this.plans = {\n      short: { '1m': 0.4, '5m': 0.4, '15m': 0.15, '1h': 0.05 },  // Day trading\n      mid: { '1m': 0.1, '5m': 0.35, '15m': 0.35, '1h': 0.2 },    // Swing trading\n      long: { '1m': 0.05, '5m': 0.15, '15m': 0.3, '1h': 0.5 }    // Position trading\n    };\n    \n    // ATR multipliers for SL/TP by plan\n    this.atrMultipliers = {\n      short: { sl: 1.0, tp: 1.5 },  // Tighter stops\n      mid: { sl: 1.5, tp: 2.0 },\n      long: { sl: 2.0, tp: 3.0 }    // Wider stops\n    };\n  }\n\n  // Analyze a symbol across all timeframes\n  async analyzeSymbol(symbol, plan = 'mid') {\n    const results = {\n      symbol,\n      plan,\n      timeframes: {},\n      indicators: {},\n      votes: {},\n      confidence: 0,\n      signal: 'HOLD',\n      sltp: null\n    };\n\n    // Analyze each timeframe\n    for (const tf of this.timeframes) {\n      const tfAnalysis = this.analyzeTimeframe(symbol, tf);\n      if (tfAnalysis) {\n        results.timeframes[tf] = tfAnalysis;\n      }\n    }\n\n    // Calculate weighted votes based on plan\n    results.votes = this.calculateVotes(results.timeframes, plan);\n    \n    // Determine overall signal and confidence\n    const { signal, confidence } = this.determineSignal(results.votes);\n    results.signal = signal;\n    results.confidence = confidence;\n\n    // Calculate SL/TP if we have a signal\n    if (signal !== 'HOLD' && results.timeframes['1h']) {\n      results.sltp = this.calculateSLTP(\n        results.timeframes['1h'].price,\n        results.timeframes['1h'].atr,\n        signal,\n        plan\n      );\n    }\n\n    // Aggregate indicators from primary timeframe (1h)\n    if (results.timeframes['1h']) {\n      results.indicators = {\n        price: results.timeframes['1h'].price,\n        rsi: results.timeframes['1h'].rsi,\n        emas: results.timeframes['1h'].emas,\n        macd: results.timeframes['1h'].macd,\n        bb: results.timeframes['1h'].bb,\n        atr: results.timeframes['1h'].atr\n      };\n    }\n\n    return results;\n  }\n\n  // Analyze a single timeframe\n  analyzeTimeframe(symbol, timeframe) {\n    const bars = this.ohlcCache.getBars(symbol, timeframe, 200);\n    \n    if (bars.length < 50) {\n      return null; // Not enough data\n    }\n\n    const closes = bars.map(b => b.close);\n    const highs = bars.map(b => b.high);\n    const lows = bars.map(b => b.low);\n\n    // Calculate indicators\n    const ema8 = EMA.calculate({ period: 8, values: closes });\n    const ema21 = EMA.calculate({ period: 21, values: closes });\n    const ema50 = EMA.calculate({ period: 50, values: closes });\n    const ema200 = EMA.calculate({ period: 200, values: closes });\n    \n    const rsiVals = RSI.calculate({ period: 14, values: closes });\n    \n    const macdResult = MACD.calculate({\n      values: closes,\n      fastPeriod: 12,\n      slowPeriod: 26,\n      signalPeriod: 9,\n      SimpleMAOscillator: false,\n      SimpleMASignal: false\n    });\n    \n    const bbResult = BollingerBands.calculate({\n      period: 20,\n      values: closes,\n      stdDev: 2\n    });\n    \n    const atrResult = ATR.calculate({\n      high: highs,\n      low: lows,\n      close: closes,\n      period: 14\n    });\n\n    // Get latest values\n    const latestIdx = closes.length - 1;\n    const price = closes[latestIdx];\n    const rsi = rsiVals[rsiVals.length - 1];\n    const macd = macdResult[macdResult.length - 1];\n    const bb = bbResult[bbResult.length - 1];\n    const atr = atrResult[atrResult.length - 1];\n\n    const emas = {\n      ema8: ema8[ema8.length - 1],\n      ema21: ema21[ema21.length - 1],\n      ema50: ema50.length > 0 ? ema50[ema50.length - 1] : null,\n      ema200: ema200.length > 0 ? ema200[ema200.length - 1] : null\n    };\n\n    // Evaluate each indicator\n    const trend = this.evaluateTrend(emas);\n    const rsiSignal = this.evaluateRSI(rsi);\n    const macdSignal = this.evaluateMACD(macd);\n    const bbSignal = this.evaluateBB(price, bb, rsi);\n\n    return {\n      timeframe,\n      price,\n      emas,\n      rsi,\n      macd,\n      bb,\n      atr,\n      signals: { trend, rsiSignal, macdSignal, bbSignal }\n    };\n  }\n\n  // Evaluate trend using EMAs\n  evaluateTrend(emas) {\n    const { ema8, ema21, ema50, ema200 } = emas;\n    \n    // Strong bullish: 8 > 21 > 50 > 200\n    if (ema8 > ema21 && ema21 > (ema50 || ema21) && (ema50 || ema21) > (ema200 || ema50 || ema21)) {\n      return { signal: 'BUY', strength: 1.0 };\n    }\n    \n    // Strong bearish: 8 < 21 < 50 < 200\n    if (ema8 < ema21 && ema21 < (ema50 || ema21) && (ema50 || ema21) < (ema200 || ema50 || ema21)) {\n      return { signal: 'SELL', strength: 1.0 };\n    }\n    \n    // Moderate bullish: 8 > 21\n    if (ema8 > ema21) {\n      return { signal: 'BUY', strength: 0.5 };\n    }\n    \n    // Moderate bearish: 8 < 21\n    if (ema8 < ema21) {\n      return { signal: 'SELL', strength: 0.5 };\n    }\n    \n    return { signal: 'HOLD', strength: 0 };\n  }\n\n  // Evaluate RSI\n  evaluateRSI(rsi) {\n    if (rsi > 60) {\n      return { signal: 'BUY', strength: Math.min((rsi - 60) / 20, 1) };\n    } else if (rsi < 40) {\n      return { signal: 'SELL', strength: Math.min((40 - rsi) / 20, 1) };\n    }\n    return { signal: 'HOLD', strength: 0 };\n  }\n\n  // Evaluate MACD\n  evaluateMACD(macd) {\n    if (!macd) return { signal: 'HOLD', strength: 0 };\n    \n    const { MACD: macdLine, signal: signalLine, histogram } = macd;\n    \n    // MACD line above signal + positive histogram\n    if (macdLine > signalLine && histogram > 0) {\n      return { signal: 'BUY', strength: Math.min(histogram / Math.abs(macdLine) * 2, 1) };\n    }\n    \n    // MACD line below signal + negative histogram\n    if (macdLine < signalLine && histogram < 0) {\n      return { signal: 'SELL', strength: Math.min(Math.abs(histogram) / Math.abs(macdLine) * 2, 1) };\n    }\n    \n    return { signal: 'HOLD', strength: 0 };\n  }\n\n  // Evaluate Bollinger Bands with RSI filter\n  evaluateBB(price, bb, rsi) {\n    if (!bb) return { signal: 'HOLD', strength: 0 };\n    \n    const { upper, middle, lower } = bb;\n    \n    // Price below lower band + RSI < 40 = oversold\n    if (price < lower && rsi < 40) {\n      return { signal: 'BUY', strength: 0.8 };\n    }\n    \n    // Price above upper band + RSI > 60 = overbought\n    if (price > upper && rsi > 60) {\n      return { signal: 'SELL', strength: 0.8 };\n    }\n    \n    return { signal: 'HOLD', strength: 0 };\n  }\n\n  // Calculate weighted votes across timeframes\n  calculateVotes(timeframes, plan) {\n    const weights = this.plans[plan] || this.plans.mid;\n    const votes = { BUY: 0, SELL: 0, HOLD: 0 };\n\n    for (const [tf, data] of Object.entries(timeframes)) {\n      const weight = weights[tf] || 0;\n      const { signals } = data;\n\n      // Aggregate signals from all indicators\n      const tfVotes = { BUY: 0, SELL: 0, HOLD: 0 };\n      \n      for (const indicator of Object.values(signals)) {\n        if (indicator.signal === 'BUY') {\n          tfVotes.BUY += indicator.strength;\n        } else if (indicator.signal === 'SELL') {\n          tfVotes.SELL += indicator.strength;\n        } else {\n          tfVotes.HOLD += 0.1;\n        }\n      }\n\n      // Apply timeframe weight\n      votes.BUY += tfVotes.BUY * weight;\n      votes.SELL += tfVotes.SELL * weight;\n      votes.HOLD += tfVotes.HOLD * weight;\n    }\n\n    return votes;\n  }\n\n  // Determine overall signal and confidence\n  determineSignal(votes) {\n    const total = votes.BUY + votes.SELL + votes.HOLD;\n    \n    if (total === 0) {\n      return { signal: 'HOLD', confidence: 0 };\n    }\n\n    const buyPct = (votes.BUY / total) * 100;\n    const sellPct = (votes.SELL / total) * 100;\n\n    // Require at least 40% consensus\n    if (buyPct > 40 && buyPct > sellPct) {\n      return { signal: 'BUY', confidence: Math.min(Math.round(buyPct), 100) };\n    }\n    \n    if (sellPct > 40 && sellPct > buyPct) {\n      return { signal: 'SELL', confidence: Math.min(Math.round(sellPct), 100) };\n    }\n\n    return { signal: 'HOLD', confidence: 0 };\n  }\n\n  // Calculate SL/TP based on ATR\n  calculateSLTP(price, atr, signal, plan) {\n    const multipliers = this.atrMultipliers[plan] || this.atrMultipliers.mid;\n\n    if (signal === 'BUY') {\n      return {\n        stopLoss: price - (atr * multipliers.sl),\n        takeProfit: price + (atr * multipliers.tp)\n      };\n    } else if (signal === 'SELL') {\n      return {\n        stopLoss: price + (atr * multipliers.sl),\n        takeProfit: price - (atr * multipliers.tp)\n      };\n    }\n\n    return null;\n  }\n}\n\nmodule.exports = StrategyEngine;\n","size_bytes":8853},"modules/http-fallback.js":{"content":"// HTTP Fallback Module - Fetches price data from CryptoCompare when WebSocket is down\n// Implements exponential backoff retry logic\n\nconst fetch = require('node-fetch');\n\nclass HTTPFallback {\n  constructor(ohlcCache, config = {}) {\n    this.ohlcCache = ohlcCache;\n    this.enabled = config.enabled !== false;\n    this.baseUrl = 'https://min-api.cryptocompare.com/data';\n    \n    // Symbol mapping\n    this.symbolMap = {\n      'btc': 'BTC',\n      'eth': 'ETH',\n      'sol': 'SOL',\n      'xrp': 'XRP',\n      'ada': 'ADA',\n      'doge': 'DOGE',\n      'bnb': 'BNB',\n      'ltc': 'LTC',\n      'matic': 'MATIC',\n      'avax': 'AVAX',\n      'dot': 'DOT',\n      'link': 'LINK'\n    };\n    \n    this.symbols = Object.keys(this.symbolMap);\n    \n    // Rate limiting\n    this.lastFetchTime = {};\n    this.minFetchInterval = 2000; // 2 seconds between requests per symbol\n    \n    // Retry config\n    this.maxRetries = 3;\n    this.baseDelay = 1000; // 1 second\n    this.maxDelay = 30000; // 30 seconds\n  }\n\n  // Fetch current price with retry logic\n  async fetchPrice(symbol, retryCount = 0) {\n    if (!this.enabled) {\n      return null;\n    }\n\n    const fsym = this.symbolMap[symbol];\n    if (!fsym) {\n      return null;\n    }\n\n    // Rate limiting check\n    const now = Date.now();\n    const lastFetch = this.lastFetchTime[symbol] || 0;\n    if (now - lastFetch < this.minFetchInterval) {\n      return null; // Too soon, skip this fetch\n    }\n\n    try {\n      const url = `${this.baseUrl}/price?fsym=${fsym}&tsyms=USD`;\n      const response = await fetch(url);\n      \n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}`);\n      }\n      \n      const data = await response.json();\n      const price = data.USD;\n      \n      if (price && !isNaN(price)) {\n        this.lastFetchTime[symbol] = now;\n        this.ohlcCache.updateTick(symbol, price, 'http');\n        return price;\n      }\n      \n      return null;\n      \n    } catch (error) {\n      console.error(`[HTTP Fallback] Error fetching ${symbol}:`, error.message);\n      this.ohlcCache.recordError(symbol);\n      \n      // Retry with exponential backoff\n      if (retryCount < this.maxRetries) {\n        const delay = Math.min(\n          this.baseDelay * Math.pow(2, retryCount),\n          this.maxDelay\n        );\n        \n        console.log(`[HTTP Fallback] Retrying ${symbol} in ${delay}ms (attempt ${retryCount + 1}/${this.maxRetries})`);\n        \n        await new Promise(resolve => setTimeout(resolve, delay));\n        return this.fetchPrice(symbol, retryCount + 1);\n      }\n      \n      return null;\n    }\n  }\n\n  // Fetch historical OHLC data for backfilling cache\n  async fetchHistoricalOHLC(symbol, timeframe = '1m', limit = 500) {\n    if (!this.enabled) {\n      return [];\n    }\n\n    const fsym = this.symbolMap[symbol];\n    if (!fsym) {\n      return [];\n    }\n\n    try {\n      // Map timeframe to CryptoCompare endpoint\n      const endpoint = this.getHistoEndpoint(timeframe);\n      const url = `${this.baseUrl}/${endpoint}?fsym=${fsym}&tsym=USD&limit=${limit}`;\n      \n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}`);\n      }\n      \n      const json = await response.json();\n      \n      if (json.Response === 'Error') {\n        throw new Error(json.Message);\n      }\n      \n      if (!json.Data || !json.Data.Data) {\n        return [];\n      }\n      \n      // Convert to our OHLC format\n      const bars = json.Data.Data.map(candle => ({\n        time: candle.time * 1000, // Convert to ms\n        open: candle.open,\n        high: candle.high,\n        low: candle.low,\n        close: candle.close,\n        volume: candle.volumefrom\n      }));\n      \n      return bars;\n      \n    } catch (error) {\n      console.error(`[HTTP Fallback] Error fetching historical ${symbol} ${timeframe}:`, error.message);\n      return [];\n    }\n  }\n\n  getHistoEndpoint(timeframe) {\n    const map = {\n      '1m': 'v2/histominute',\n      '5m': 'v2/histominute',\n      '15m': 'v2/histominute',\n      '1h': 'v2/histohour',\n      '1d': 'v2/histoday'\n    };\n    return map[timeframe] || 'v2/histominute';\n  }\n\n  // Fetch all symbols (for periodic refresh when WS is down)\n  async fetchAllPrices() {\n    const results = {};\n    \n    for (const symbol of this.symbols) {\n      const price = await this.fetchPrice(symbol);\n      if (price) {\n        results[symbol] = price;\n      }\n      // Small delay between requests to respect rate limits\n      await new Promise(resolve => setTimeout(resolve, 300));\n    }\n    \n    return results;\n  }\n\n  // Initialize cache by backfilling historical data\n  async initializeCache() {\n    if (!this.enabled) {\n      console.log('[HTTP Fallback] Disabled, skipping cache initialization');\n      return;\n    }\n\n    console.log('[HTTP Fallback] Initializing OHLC cache with historical data...');\n    \n    for (const symbol of this.symbols) {\n      try {\n        // Fetch 1m bars\n        const bars1m = await this.fetchHistoricalOHLC(symbol, '1m', 500);\n        if (bars1m.length > 0) {\n          this.ohlcCache.loadHistoricalBars(symbol, '1m', bars1m);\n        }\n        \n        // Fetch 5m bars (we can aggregate from 1m, but let's fetch directly for now)\n        // Note: CryptoCompare doesn't have native 5m, so we'll aggregate later\n        \n        // Small delay between symbols\n        await new Promise(resolve => setTimeout(resolve, 500));\n        \n      } catch (error) {\n        console.error(`[HTTP Fallback] Error initializing ${symbol}:`, error.message);\n      }\n    }\n    \n    console.log('[HTTP Fallback] Cache initialization complete');\n  }\n\n  // Aggregate 1m bars into 5m bars\n  aggregate1mTo5m(bars1m) {\n    const bars5m = [];\n    \n    for (let i = 0; i < bars1m.length; i += 5) {\n      const chunk = bars1m.slice(i, i + 5);\n      if (chunk.length === 0) continue;\n      \n      const bar5m = {\n        time: chunk[0].time,\n        open: chunk[0].open,\n        high: Math.max(...chunk.map(b => b.high)),\n        low: Math.min(...chunk.map(b => b.low)),\n        close: chunk[chunk.length - 1].close,\n        volume: chunk.reduce((sum, b) => sum + b.volume, 0)\n      };\n      \n      bars5m.push(bar5m);\n    }\n    \n    return bars5m;\n  }\n}\n\nmodule.exports = HTTPFallback;\n","size_bytes":6245},"modules/binance-ws.js":{"content":"// Binance WebSocket Module - Real-time price stream\n// Connects to Binance WebSocket API for live price updates\n\nconst WebSocket = require('ws');\n\nclass BinanceWS {\n  constructor(ohlcCache, config = {}) {\n    this.ohlcCache = ohlcCache;\n    this.enabled = config.enabled !== false;\n    this.ws = null;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 10;\n    this.reconnectDelay = 1000; // Start with 1 second\n    this.isConnected = false;\n    this.lastPingTime = null;\n    \n    // Symbol mapping (lowercase to Binance format)\n    this.symbolMap = {\n      'btc': 'BTCUSDT',\n      'eth': 'ETHUSDT',\n      'sol': 'SOLUSDT',\n      'xrp': 'XRPUSDT',\n      'ada': 'ADAUSDT',\n      'doge': 'DOGEUSDT',\n      'bnb': 'BNBUSDT',\n      'ltc': 'LTCUSDT',\n      'matic': 'MATICUSDT',\n      'avax': 'AVAXUSDT',\n      'dot': 'DOTUSDT',\n      'link': 'LINKUSDT'\n    };\n    \n    this.symbols = Object.keys(this.symbolMap);\n  }\n\n  // Start WebSocket connection\n  connect() {\n    if (!this.enabled) {\n      console.log('[Binance WS] WebSocket disabled via config');\n      return;\n    }\n\n    // Build stream URL for all symbols (combined stream)\n    const streams = this.symbols\n      .map(sym => `${this.symbolMap[sym].toLowerCase()}@trade`)\n      .join('/');\n    \n    const url = `wss://stream.binance.com:9443/stream?streams=${streams}`;\n    \n    console.log(`[Binance WS] Connecting to Binance WebSocket...`);\n    console.log(`[Binance WS] Monitoring ${this.symbols.length} symbols`);\n    \n    try {\n      this.ws = new WebSocket(url);\n      \n      this.ws.on('open', () => this.onOpen());\n      this.ws.on('message', (data) => this.onMessage(data));\n      this.ws.on('error', (error) => this.onError(error));\n      this.ws.on('close', () => this.onClose());\n      this.ws.on('ping', () => this.onPing());\n      \n    } catch (error) {\n      console.error('[Binance WS] Failed to create WebSocket:', error.message);\n      this.scheduleReconnect();\n    }\n  }\n\n  onOpen() {\n    console.log('[Binance WS] ‚úÖ Connected to Binance');\n    this.isConnected = true;\n    this.reconnectAttempts = 0;\n    this.reconnectDelay = 1000;\n    this.lastPingTime = Date.now();\n  }\n\n  onMessage(data) {\n    try {\n      const message = JSON.parse(data);\n      \n      // Binance combined stream format: { stream: \"btcusdt@trade\", data: {...} }\n      if (message.stream && message.data) {\n        this.handleTrade(message);\n      }\n    } catch (error) {\n      console.error('[Binance WS] Error parsing message:', error.message);\n    }\n  }\n\n  handleTrade(message) {\n    try {\n      const stream = message.stream;\n      const data = message.data;\n      \n      // Extract symbol from stream name (e.g., \"btcusdt@trade\" -> \"btc\")\n      const binanceSymbol = stream.split('@')[0].toUpperCase();\n      const symbol = this.getSymbolFromBinance(binanceSymbol);\n      \n      if (!symbol) {\n        return; // Unknown symbol\n      }\n      \n      // Extract price from trade data\n      const price = parseFloat(data.p);\n      \n      if (!isNaN(price) && price > 0) {\n        // Update OHLC cache\n        this.ohlcCache.updateTick(symbol, price, 'ws');\n      }\n      \n    } catch (error) {\n      console.error('[Binance WS] Error handling trade:', error.message);\n    }\n  }\n\n  onError(error) {\n    console.error('[Binance WS] Error:', error.message);\n    this.isConnected = false;\n  }\n\n  onClose() {\n    console.log('[Binance WS] Connection closed');\n    this.isConnected = false;\n    this.scheduleReconnect();\n  }\n\n  onPing() {\n    this.lastPingTime = Date.now();\n  }\n\n  scheduleReconnect() {\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.error('[Binance WS] Max reconnection attempts reached. Giving up.');\n      return;\n    }\n\n    this.reconnectAttempts++;\n    const delay = Math.min(this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1), 30000);\n    \n    console.log(`[Binance WS] Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n    \n    setTimeout(() => {\n      this.connect();\n    }, delay);\n  }\n\n  getSymbolFromBinance(binanceSymbol) {\n    for (const [key, value] of Object.entries(this.symbolMap)) {\n      if (value === binanceSymbol) {\n        return key;\n      }\n    }\n    return null;\n  }\n\n  // Close connection\n  disconnect() {\n    if (this.ws) {\n      console.log('[Binance WS] Disconnecting...');\n      this.enabled = false;\n      this.ws.close();\n      this.ws = null;\n    }\n  }\n\n  // Get connection status\n  getStatus() {\n    return {\n      enabled: this.enabled,\n      connected: this.isConnected,\n      reconnectAttempts: this.reconnectAttempts,\n      lastPing: this.lastPingTime,\n      uptime: this.lastPingTime ? Date.now() - this.lastPingTime : null\n    };\n  }\n}\n\nmodule.exports = BinanceWS;\n","size_bytes":4765},"modules/paper-trading.js":{"content":"const fs = require('fs').promises;\nconst path = require('path');\n\nclass PaperTrading {\n  constructor(strategyEngine, config = {}) {\n    this.strategyEngine = strategyEngine;\n    this.dataFile = path.join(__dirname, '..', 'paper-portfolio.json');\n    \n    this.config = {\n      initialBalance: config.initialBalance || 1000,\n      positionSize: config.positionSize || 0.10,\n      maxPositions: config.maxPositions || 3,\n      stopLossPct: config.stopLossPct || 0.02,\n      takeProfitPct: config.takeProfitPct || 0.05,\n      plan: config.plan || 'short',\n      ...config\n    };\n    \n    this.portfolio = null;\n  }\n\n  async initialize() {\n    try {\n      const data = await fs.readFile(this.dataFile, 'utf8');\n      this.portfolio = JSON.parse(data);\n      console.log('üìä Paper portfolio loaded:', {\n        balance: this.portfolio.balance,\n        positions: this.portfolio.positions.length,\n        trades: this.portfolio.trades.length\n      });\n    } catch (error) {\n      console.log('üìä Creating new paper trading portfolio...');\n      this.portfolio = {\n        balance: this.config.initialBalance,\n        initialBalance: this.config.initialBalance,\n        positions: [],\n        trades: [],\n        metrics: {\n          totalTrades: 0,\n          wins: 0,\n          losses: 0,\n          totalProfit: 0,\n          totalLoss: 0,\n          winRate: 0,\n          avgWin: 0,\n          avgLoss: 0,\n          profitFactor: 0,\n          maxDrawdown: 0,\n          peakBalance: this.config.initialBalance\n        },\n        startedAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n      };\n      await this.save();\n    }\n  }\n\n  async save() {\n    this.portfolio.updatedAt = new Date().toISOString();\n    await fs.writeFile(this.dataFile, JSON.stringify(this.portfolio, null, 2));\n  }\n\n  async checkAndExecuteTrades(symbols) {\n    if (!this.portfolio) {\n      await this.initialize();\n    }\n\n    const actions = [];\n\n    for (const symbol of symbols) {\n      const analysis = await this.strategyEngine.analyzeSymbol(symbol, this.config.plan);\n      \n      if (!analysis || !analysis.indicators || !analysis.indicators.price) {\n        continue;\n      }\n\n      const currentPrice = analysis.indicators.price;\n      const signal = analysis.signal;\n      const confidence = analysis.confidence;\n\n      const existingPosition = this.portfolio.positions.find(p => p.symbol === symbol);\n\n      if (existingPosition) {\n        const action = await this.checkExitConditions(existingPosition, currentPrice, signal, confidence);\n        if (action) actions.push(action);\n      } else {\n        const action = await this.checkEntryConditions(symbol, currentPrice, signal, confidence, analysis.sltp);\n        if (action) actions.push(action);\n      }\n    }\n\n    if (actions.length > 0) {\n      await this.save();\n    }\n\n    return actions;\n  }\n\n  async checkEntryConditions(symbol, price, signal, confidence, sltp) {\n    if (signal === 'HOLD' || confidence < 50) {\n      return null;\n    }\n\n    if (this.portfolio.positions.length >= this.config.maxPositions) {\n      return null;\n    }\n\n    if (signal !== 'BUY') {\n      return null;\n    }\n\n    const positionValue = this.portfolio.balance * this.config.positionSize;\n    const quantity = positionValue / price;\n\n    if (positionValue > this.portfolio.balance) {\n      return null;\n    }\n\n    const stopLoss = sltp && sltp.stopLoss ? sltp.stopLoss : price * (1 - this.config.stopLossPct);\n    const takeProfit = sltp && sltp.takeProfit ? sltp.takeProfit : price * (1 + this.config.takeProfitPct);\n\n    const position = {\n      symbol,\n      side: 'LONG',\n      entryPrice: price,\n      quantity,\n      positionValue,\n      stopLoss,\n      takeProfit,\n      confidence,\n      entryTime: new Date().toISOString(),\n      entryReason: `${signal} signal with ${confidence}% confidence`\n    };\n\n    this.portfolio.positions.push(position);\n    this.portfolio.balance -= positionValue;\n\n    const trade = {\n      id: `${symbol}-${Date.now()}`,\n      symbol,\n      side: 'LONG',\n      action: 'ENTRY',\n      price,\n      quantity,\n      value: positionValue,\n      confidence,\n      balance: this.portfolio.balance,\n      timestamp: new Date().toISOString(),\n      reason: position.entryReason\n    };\n\n    this.portfolio.trades.push(trade);\n\n    console.log(`‚úÖ PAPER BUY: ${symbol.toUpperCase()} @ $${price.toFixed(2)} (${confidence}% confidence)`);\n\n    return {\n      type: 'ENTRY',\n      symbol,\n      price,\n      quantity,\n      confidence,\n      stopLoss,\n      takeProfit\n    };\n  }\n\n  async checkExitConditions(position, currentPrice, signal, confidence) {\n    let exitReason = null;\n\n    if (currentPrice <= position.stopLoss) {\n      exitReason = `Stop-loss hit at $${currentPrice.toFixed(2)}`;\n    } else if (currentPrice >= position.takeProfit) {\n      exitReason = `Take-profit hit at $${currentPrice.toFixed(2)}`;\n    } else if (signal === 'SELL' && confidence >= 50) {\n      exitReason = `SELL signal with ${confidence}% confidence`;\n    }\n\n    if (!exitReason) {\n      return null;\n    }\n\n    const exitValue = position.quantity * currentPrice;\n    const profit = exitValue - position.positionValue;\n    const profitPct = (profit / position.positionValue) * 100;\n\n    this.portfolio.balance += exitValue;\n\n    const positionIndex = this.portfolio.positions.indexOf(position);\n    this.portfolio.positions.splice(positionIndex, 1);\n\n    const trade = {\n      id: `${position.symbol}-${Date.now()}`,\n      symbol: position.symbol,\n      side: position.side,\n      action: 'EXIT',\n      entryPrice: position.entryPrice,\n      exitPrice: currentPrice,\n      quantity: position.quantity,\n      entryValue: position.positionValue,\n      exitValue,\n      profit,\n      profitPct,\n      balance: this.portfolio.balance,\n      timestamp: new Date().toISOString(),\n      reason: exitReason,\n      holdTime: this.calculateHoldTime(position.entryTime)\n    };\n\n    this.portfolio.trades.push(trade);\n\n    await this.updateMetrics(profit);\n\n    const emoji = profit >= 0 ? '‚úÖ' : '‚ùå';\n    console.log(`${emoji} PAPER SELL: ${position.symbol.toUpperCase()} @ $${currentPrice.toFixed(2)} | P/L: $${profit.toFixed(2)} (${profitPct.toFixed(2)}%)`);\n\n    return {\n      type: 'EXIT',\n      symbol: position.symbol,\n      entryPrice: position.entryPrice,\n      exitPrice: currentPrice,\n      profit,\n      profitPct,\n      reason: exitReason\n    };\n  }\n\n  calculateHoldTime(entryTime) {\n    const entry = new Date(entryTime);\n    const now = new Date();\n    const diffMs = now - entry;\n    const diffMins = Math.floor(diffMs / 60000);\n    \n    if (diffMins < 60) return `${diffMins}m`;\n    const diffHours = Math.floor(diffMins / 60);\n    if (diffHours < 24) return `${diffHours}h`;\n    const diffDays = Math.floor(diffHours / 24);\n    return `${diffDays}d`;\n  }\n\n  async updateMetrics(profit) {\n    const m = this.portfolio.metrics;\n    \n    m.totalTrades++;\n    \n    if (profit > 0) {\n      m.wins++;\n      m.totalProfit += profit;\n    } else {\n      m.losses++;\n      m.totalLoss += Math.abs(profit);\n    }\n    \n    m.winRate = m.totalTrades > 0 ? (m.wins / m.totalTrades) * 100 : 0;\n    m.avgWin = m.wins > 0 ? m.totalProfit / m.wins : 0;\n    m.avgLoss = m.losses > 0 ? m.totalLoss / m.losses : 0;\n    m.profitFactor = m.totalLoss > 0 ? m.totalProfit / m.totalLoss : 0;\n\n    await this.refreshPeakAndDrawdown();\n  }\n\n  async refreshPeakAndDrawdown() {\n    const m = this.portfolio.metrics;\n    const totalValue = await this.getTotalValue();\n    \n    if (totalValue > m.peakBalance) {\n      m.peakBalance = totalValue;\n    }\n    \n    const drawdown = m.peakBalance > 0 ? ((m.peakBalance - totalValue) / m.peakBalance) * 100 : 0;\n    if (drawdown > m.maxDrawdown) {\n      m.maxDrawdown = drawdown;\n    }\n  }\n\n  async getTotalValue() {\n    let total = this.portfolio.balance;\n    \n    for (const pos of this.portfolio.positions) {\n      const currentPrice = await this.getCurrentPrice(pos.symbol);\n      if (currentPrice) {\n        total += pos.quantity * currentPrice;\n      } else {\n        total += pos.positionValue;\n      }\n    }\n    \n    return total;\n  }\n\n  async getCurrentPrice(symbol) {\n    try {\n      const analysis = await this.strategyEngine.analyzeSymbol(symbol, this.config.plan);\n      return analysis && analysis.indicators && analysis.indicators.price ? analysis.indicators.price : null;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  async getPerformance() {\n    await this.refreshPeakAndDrawdown();\n    \n    const totalValue = await this.getTotalValue();\n    const totalReturn = totalValue - this.portfolio.initialBalance;\n    const totalReturnPct = (totalReturn / this.portfolio.initialBalance) * 100;\n\n    return {\n      balance: this.portfolio.balance,\n      positionsValue: totalValue - this.portfolio.balance,\n      totalValue,\n      initialBalance: this.portfolio.initialBalance,\n      totalReturn,\n      totalReturnPct,\n      positions: this.portfolio.positions.length,\n      metrics: this.portfolio.metrics,\n      startedAt: this.portfolio.startedAt,\n      updatedAt: this.portfolio.updatedAt\n    };\n  }\n\n  getTrades(limit = 50) {\n    return this.portfolio.trades.slice(-limit).reverse();\n  }\n\n  async getPositions() {\n    const enrichedPositions = [];\n    \n    for (const pos of this.portfolio.positions) {\n      const currentPrice = await this.getCurrentPrice(pos.symbol);\n      const enriched = { ...pos };\n      \n      if (currentPrice) {\n        enriched.currentPrice = currentPrice;\n        enriched.currentValue = pos.quantity * currentPrice;\n        enriched.unrealizedPnL = enriched.currentValue - pos.positionValue;\n        enriched.unrealizedPnLPct = (enriched.unrealizedPnL / pos.positionValue) * 100;\n      }\n      \n      enrichedPositions.push(enriched);\n    }\n    \n    return enrichedPositions;\n  }\n}\n\nmodule.exports = PaperTrading;\n","size_bytes":9836}},"version":2}